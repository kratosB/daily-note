## aqs condition分析

1. 看文章的时候就好奇为什么`!isOnSyncQueue(node)`这句会是true，往下看解惑了。
   1. 另一个线程signal之后，之前park的线程，会从条件队列移到同步队列，但是还没被唤醒。然后这个线程被unpark之后，再循环一次，发现已经在同步队列了，就跳出循环。
   2. 主要就是signal和unlock，之前有点搞混了。park需要unlock（中的release）的unpark，signal主要针对await。（signal里面也包括一点点unpark）
   3. 这里想到循环打印abc，用conditon的例子。signal之后，并不是直接唤醒，而是放进了同步队列。
2. 自己测试了一下，await之后，一定要被signal，不然哪怕其他线程unlock，可能也不会被unpark。（当然根据源码，哪怕被unpark，也还会继续在循环里转）
   1. 在`LockSupport.park(this);`之后，其他线程没有signal直接unlock，会因为这个线程在条件队列（所以同步队列没东西），触发`if (h != null && h.waitStatus != 0)`的第一或者第二个条件，导致直接跳过`unparkSuccessor(h);`这个方法，直接返回true，所以之前park的方法就没有被unpark。
      1. 这个地方大概也说明了，unlock（之中的release）只能unpark同步队列里等待的线程。
   2. 所以这个地方的park，在线程没有被从条件队列转到同步队列的情况下，可能只能被`transferForSignal`方法中的`LockSupport.unpark(node.thread);`唤醒。或者在该线程被`thread.interrupt()`的时候唤醒（然后直接从后面的if中break出循环）。
