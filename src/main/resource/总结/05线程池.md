## 总结 - 05线程池
1. ThreadPoolExecutor 有哪些常用的方法？
   1. execute/submit
   2. shutdown/shutdownnow
   3. isShutdown
   4. getCorePoolSize
   5. getQueue
   6. allowCoreThreadTimeOut
   7. prestartAllCoreThreads
2. 说说submit和 execute两个方法有什么区别？
   1. execute runnable
   2. submit runnable和callable，包装成futureTask，future收集结果
3. shutdownNow() 和 shutdown() 两个方法有什么区别？
   1. 一个是不接收新的任务。interruptIdleWorkers
   2. 一个是queue中的东西不要了，正在做的也不要了，立马停止。interruptWorkers
4. 了解过线程池的工作原理吗？
   1. 有没有足够多的核心线程在工作，没有的话起一个，
   2. 所有核心线程都在工作，就往队列里放任务
   3. 队列里也放满了，就创建非核心线程做任务
   4. 非核心线程也满了，就按照异常策略处理
5. 线程池中核心线程数量大小怎么设置？
   1. 理论上，吃IO的可以设置成两倍，吃cpu的设置成cpu数+1 
   2. 实际上要自己调优
   3. 还可以动态设置，用setCorePoolSize和setMaxPoolSize
6. 线程池为什么需要使用（阻塞）队列？
   1. 为什么使用队列，因为如果来一个任务创建一个线程，可能线程数量太大，OOM+cpu频繁切换。
7. 线程池为什么要使用阻塞队列而不使用非阻塞队列？
   1. 当没有任务的时候，阻塞队列可以让线程idle。非阻塞线程会一直吃资源，或者需要使用一些手段变成阻塞。那不如直接用现成的。
8. 了解线程池状态吗？
   1. running
   2. shutdown
   3. stop
   4. tidying
   5. terminated
9. 知道线程池中线程复用原理吗？
   1. worker做完工作后，去阻塞队列拿新任务，执行run方法。没任务就等着，或者关掉。
10. 说说线程池创建需要的那几个核心参数的含义
    1. corePoolSize:核心线程数
    2. maxPoolSize:最大线程数
    3. unit:单位
    4. keepAliveTime:超时时间
    5. workQueue:队列
    6. threadFactory:创建工厂
    7. rejectedExecutionHandler:拒绝策略
11. 线程池里的ctl是干啥的。
    1. ctl是线程池状态和worker数量的结合
    2. 高三位是线程池状态
    3. 低29位是worker数量
    4. 跟读写锁state有点类似
    5. 这样设计的优势是，一致性更容易维护。
12. 为什么要把任务先放在任务队列里面，而不是把线程先拉满到最大线程数？
    1. 设计本意就是用corePool来完成任务，queue缓冲，max是应急。也可以有不同的设计。
    2. java线程池设计本意可能就是处理偏吃cpu资源的任务。
    3. tomcat池就是偏向吃io资源的池，所以就是直接去创建到max。
13. 如何修改原生线程池，使得可以先拉满线程数再入任务队列排队？
    1. 在execute方法中，queue.offer返回false的时候才会走到里面，才有机会走到addWorker。
    2. 修改queue的offer方法，在里面判断一下。（tomcat就是这么做的）
       1. 如果线程数<max且没有空线程，就创建（return false）。
       2. 如果线程数<max但是有空，就入队。
       3. 如果=max，就入队。
       4. 其他情况，入队（这样可以抛出原本的队列满了的错误）。
    3. [线程池三大问题和改进](https://www.cnblogs.com/luozhiyun/p/12037536.html)
14. 如果线程池中的线程在执行任务的时候，抛异常了，会怎么样？
    1. 把这个线程废了，移除，然后新建一个线程替换之，继续执行新任务。
    2. 异常的任务后面的逻辑就不做了，所以要自己捕获异常，给之前的任务做补偿。
15. 原生线程池的核心线程一定伴随着任务慢慢创建的吗？
    1. prestartCoreThread
    2. prestartAllCoreThread
16. 线程池的核心线程在空闲的时候一定不会被回收吗？
    1. allowCoreThreadTimeOut=true，就可以回收了
17. Worker本身也是一个锁，用来判断是否正在工作。



# 引用
[如图两道面试题，顺便深入线程池，并连环17问](https://mp.weixin.qq.com/s/bqK7ALIsnU91YMysAr3INQ#)
[面试官：你给我说一下线程池里面的几把锁](https://mp.weixin.qq.com/s/hduWrrK4B8x8Z3C7RnIhjw)