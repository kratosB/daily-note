## 1. 通知模块

通知模块（短信，邮件等）的重构，新运营商的接入，以及邮件打开率统计。

1. 重构通知模块
   1. S：因为要使用springboot框架。
   2. T：重构通知模块。
   3. A：1. 接入springboot，2. 引入jpa，3. 重构数据库部分（旧的数据库设计不合理，每次发送要插入好多数据，新的更简单/直观），4. 增加发送job和统计job。
   4. R：1. 模块上线，2. 发送异步处理，3. 读老代码（发送部分），学会模板方法模式，4. 更熟悉springboot。
2. 接入腾讯云短信通道，实现多通道交替发送，以及短信的补发策略。
   1. S：因为金融行业监管，亿美有时候发短信会失败，所以需要开发一个新的通道做备用。
   2. T：接入腾讯云的通道。
   3. A：1. 接入新的通道，设计交替发送策略（根据配置中心做配比，有点类似加权轮询），job扫表补发（扫描发送失败，未补发，且不是补发短信的记录）
   4. R：1. 成功接入腾讯云通道，2. 实现多通道按比例交替发送，3. 短信发送失败实施补发。
3. 实现场景发送功能，使调用方可以通过一个场景发送多种通知。
   1. S：现有的消息发送方式是“给消息服务发送一个请求，附带电话/邮箱地址，内容等信息，然后发送短信/邮件。如果要发多个短信/邮件，就得调用接口好几次”，产品想要实现一种“给消息服务发送一个请求，告诉它对应的场景和客户，消息服务自动获取客户的联系方式，通信方式（这个场景要发送邮件还是短信），然后发送消息。除此之外，产品还想要在可视化界面配置这些场景”。
   2. T：在通知模块中，增加一个场景管理/发送的模块，实现场景发送功能。
   3. A：1. 在短信/邮件/微信消息的上层，再抽象出一层场景，数据库设计表。2. 实现场景编辑功能。3. 实现场景发送（按编号找到对应场景，然后找到场景中的信息，循环发送）。
   4. R：1. 实现场景发送。
4. 通过邮件埋点，实现打开率统计。
   1. S：领导想要了解我们的邮件到底有没有用，有没有人看，所以要统计一下打开率。
   2. T：1. 代码植入。2. 间谍像素。
   3. A：1. 在所有邮件的最后，增加一个间谍像素，附带一个id。2. 用户打开邮件的时候，访问间谍像素，用拦截器拦截这个请求，在数据库中更新打开情况。
   4. R：1. 部分邮箱实现功能。（部分有像会屏蔽间谍像素，例如腾讯邮箱）。2. 学到例如短链接转换的思想。

## 2. 微信公众平台

关联群星平台账号和用户微信账号，实现微信端登录，通知推送等功能。

1. 实现微信菜单，基于Oauth2.0的微信网页授权及页面重定向。
   1. 后台服务器调用微信服务器，创建菜单（包括oauth网页授权链接）
   2. 用户点击微信菜单，对微信服务器发起请求
   3. 微信请求用户授权
   4. 用户授权后，微信服务器重定向到配置的地址，并附带code
   5. 后台服务通过code获取用户token及用户信息。
   6. 判断用户是否绑定，如果未绑定，则重定向到绑定登录页面。
   7. 如果已经绑定，则后台触发一次登录动作，获取平台的token
   8. 根据参数从缓存中获取重定向信息
   9. 重定向页面，并附带平台token
2. 微信账号和平台账号的整合关联。
   1. 用户搜索并关注服务号。
   2. 后台服务（1044）收到微信服务器的消息，内容包括event，eventKey和openId。
   3. 后台服务根据openId从微信获取用户的unionId信息，保存/更新。
   4. 根据unionId判断之前是否绑定过，如果没绑定过，判断是普通关注还是带参数的关注（带参数的二维码），发送对应的欢迎消息（附带一个链接）。
      1. 如果有参数，后台根据参数从缓存中拿到userId/cellphone等信息，附在请求里。
   5. 用户点击链接之后，微信提示用户授权，用户点击授权。微信把请求重定向到群星平台后台服务，附带code等信息。
   6. 后台服务通过code，从微信获取客户授予的token。
   7. 后台服务通过token，从微信服务器获取用户信息（昵称，头像等等）。
      1. 如果不是“带参数的二维码”场景，后台服务把用户重定向到登录页面（带上unionId等信息，登录之后为用户绑定）
      2. 如果是“带参数的二维码”场景，直接帮用户绑定，然后重定向到用户主页。
3. 微信消息处理（自动回复和通知推送）。
4. 微信扫码登录
   1. 打开页面的时候，请求微信服务器，获取二维码，二维码包含uuid。
   2. 页面定时请求后台（看看有没有收到微信的回复），有超时时间，免得一直损耗资源。
   3. 手机扫码，给微信发请求，微信服务器让你授权
   4. 授权之后微信服务器在“后台下一次请求微信服务器”的时候授予权限
   5. 后台拿到权限之后可以用code请求token，获取到数据，登录成功。
5. 微信登录

## 3. 基于SpringCloud的平台改造

参与平台的springcloud改造。

1. 实现Zuul网关。
   1. Zuul反向代理。
   2. Ribbon负载均衡。
   3. 通过ZuulFilter过滤器，实现请求的鉴权，过滤，以及错误统一处理等功能。
      1. jwt
         1. header，tk类型，算法
         2. payload，用户信息
         3. 签名，header+payload+算法+secret（公共密码）+base64
      2. 鉴权流程
         1. 解析jwt，校验jwt是否被篡改
         2. 校验token是否超时，更新redis中的token超时时间。（我们这边采用redis刷新时间（参考oauth授权的key能用很久））
         3. 从payload中解析出用于获取登录信息的key（user+salt+md5）
         4. 从redis中获取登录信息，返回。
      3. 登录流程
         1. 申请一个token。
            1. userId+salt+md5做成一个key（后面redis存登录用户信息就用这个key）。
            2. key+salt+role做成payload的content。
            3. base64编码生成一个header（内容是写死的JWT+HS256）。
            4. base64编码生成一个payload（内容是userId，content）。
            5. 选择签名算法，根据密钥创建签名方式
            6. 加签（header+payload）
         2. 把token存到redis。
         3. 以token的payload里面的content中的key作为key，将用户登录信息放入缓存。
         4. 组装登录的返回信息。
2. 实现SpringCloud Config配置中心。
   1. 实现微服务配置集中管理。
   2. 实现配置中心加密/解密。
   3. 通过Git的Webhook和SpringCloud Bus实现了配置热部署。
   4. 实现区分环境（开发环境/测试环境/正式环境）的配置仓库管理方案。

## 4. 用户/客户模块

用户/客户模块基础功能的开发及维护。

1. 微服务重构接入SpringCloud。
2. 数据库查询优化和缓存。

   1. 查缓存->（没有的情况）查数据库->回写缓存
   2. 更新数据库->删除缓存
   3. redis key=表名+主键
   4. 主动式缓存：提前将可能访问到的数据加载到缓存中，然后设置过期时间，周期性刷新。我这边，主要是有一个页面，需要统计数量，涉及的表比较多，但是又不需要非常精确，所以用了job，定期去查，然后放进缓存，设置超时时间。
   5. 被动式缓存：就是上面这种查到之后放进缓存的方式。
   6. 一致性：
      1. 设置一个较短的超时时间。（缺点是，缓存可能没用上）
      2. 更新数据同时删除缓存。
         1. 更新前删（缺点是，删->更新 这个过程中，可能有查询进来，又放进缓存了，所以要延时双删）
         2. 更新后删（缺点是，可能会没删掉，需要用队列或者啥来维护，坏处是可能会太复杂）
   7. 缓存穿透：
      1. 问题：系统中不存在的数据，不会被缓存，相当于缓存失效了。
      2. 办法：空标记，把对应的key-value（这里key是查询条件，value是空）放进缓存。
   8. 缓存击穿
      1. 问题：热点key，失效的瞬间，大量请求直接打爆数据库。
      2. 办法：分布式锁，缓存失效，查数据库的地方，只允许一个线程访问。
   9. 缓存雪崩
      1. 问题：在同一时间有大量缓存一起失效。
      2. 办法：对不同的缓存设置不同的过期时间。
3. 类雪花算法key

   1. 新增一个点，今天排查问题的时候。发现一个数据库主键冲突，多service创建主键的时候的问题。
      现有的方法是 业务码（比方说SO） + 设备号（比方说0，1，2，每个机器不一样）+时间戳精确到秒后三位。
      每次存下上次的id，下次来了之后对比是否相等。如果id相等，则在后面+一个count（单机环境没问题）。如果不相等，直接用新的。
      今天的问题是，serviceId没配，所以两台机器id冲突了。
4. 读写分离
5. redis key怎么设计（用hashmap数据类型是不是好一点，一个map代表一个表，里面是，主键->数据，或者，查询条件字段->数据）
6. mysql更新之后remove缓存中对应的key
7. 有些数据，允许有一定的滞后和不精确。
   比方booking页面上的一些细分类（经济型/舒适性/豪华型）后面都会跟上数量，如果每个用户登录的时候都去数据库查，不合适，因为用户可能并不需要非常精确的数据，可以很花资源。
   可以做成job定时去跑，然后更新到缓存中，后面用户在主页的时候，直接去缓存中取用。这样可以快速返回，并节约数据库的资源。
   用户如果点击了这个链接，进入相应的页面，再查出精确的数字，并更新缓存。
   除此之外，job定时跑的时间也可以细分，有些不太会改变的数据，job就不用跑太频繁。比如之前做的时候，有xx类型的企业的数量。
8. 主动式缓存/被动式缓存
9. 帖子里看到的，可以联系到2里面去，主动式是事先查，类似我上面2中提到的job，被动式就是查到更新缓存。参考帖子https://mp.weixin.qq.com/s/aQLX5w9EpgeDvJrhIlOFxw
10. 这个帖子里还提到了缓存数据一致性的问题，提了两种方案。但是没说到我想的“更新之前先删除缓存”的方案，不太理解，可以研究一下。

    > 今天突然想到了“更新之前先删除缓存”的坏处，在类似秒杀的场景下，如果用缓存做库存，每次秒杀卖出去1件都要更新db，然后删除缓存，那么缓存不就形同虚设了吗？
    > 这种操作更适合读多写少的场景。**可能秒杀场景，就不适合使用数据库缓存一致，应该直接扣缓存**？
    >
    >> 今天看到一个讲缓存一致性的帖子，解决了我《更新之前先删除缓存”的方案》的疑惑。[缓存一致性问题怎么解决](https://mp.weixin.qq.com/s/aJ33A5O2PUcUOA34kL-Nzw)
    >>
    >
11. 这个帖子中，还有应对缓存穿透/击穿/雪崩的方案，感觉这个帖子里的东西，可以单独记录在redis目录下了。

鉴权[单点登录原理与简单实现](https://mp.weixin.qq.com/s/61uu9J_TX2U-JTDGEOC3pw)

## 5. 公共服务模块

整合了许多基础功能，供其他微服务调用。

1. 票据处理（调用第三方识别发票，订单等票据）
   1. pdf转图片内存溢出
      1. 最先想到肯定是调虚拟机内存xms xmx
      2. 减少线程（网上分割pdf的操作其实也类似）（这里可以说System里面设置线程池失败，要手动创建forkJoinPool来设置）
      3. 调整pdfbox的版本
      4. 降低分辨率（动态调整分辨率，大图片缩小，小图片不变）
      5. 最后把直接返回做成了邮件通知，多线程改成单线程。
      6. 按照apache的方法去优化了。（官方推荐设置）
   2. 图片识别接口，图片太大
      1. 先手动测试找到一个大概的阈值
      2. 然后所有的图片压缩到这个阈值范围内大小
   3. 图片识别完，验真失败，需要人工调整
      1. 直接在返回的文件上修改，修改完之后上传重验，只验失败的数据，不用两个excel来回倒数据，方便操作。
2. 附件管理。
   1. 下载有两种方式：
      1. 直接回写流
      2. 返回静态地址，让用户直接下载，nginx配置/download直接访问静态文件。
3. 验证码管理。
4. 通过redis实现长短链接转换。
   1. 长->短
      1. 首先，判断链接时效性，长期有效的走数据库，短期有效的直接走redis（设置超时时间）。
      2. 选一种编码方式（随机6位数字符串），对长连接进行编码，判断数据库和redis中是否存在（如果存在，则重新随机）。
      3. 把键值对（短链接索引-长连接）存入数据库或redis。
      4. 在域名后面加上短链接索引，得到类似www.iqunxing.com/s/123456的短链接。（如果能再搞一个更精简的域名就更好了）
      5. 返回给用户（前端或者短信微信邮件等）。
   2. 短->长
      1. 用户点击短链接，访问服务器。
      2. 服务器上，ngingx已经配好了/s/的直接跳转到某一台服务。
      3. 跳到指定服务后，访问对应接口。
      4. 访问对应接口，先查找redis里面有没有短链接里这个key，没有的话再找mysql。
      5. 如果找到，直接重定向。没找到，重定向到主页。

pdf转图片+图片识别+发票验真

1. 转图片（内存优化）
   1. https://www.cnblogs.com/firstdream/p/5536013.html
   2. https://www.cnblogs.com/dyllove98/archive/2012/04/24/2468771.html
   3. https://blog.csdn.net/win7system/article/details/53747032

## 6. 后台服务AWS改造迁移

将老的微服务迁移到亚马逊的AWS上，并让服务能够正确运行。

1. EC2，Beanstalk等AWS组件的配置部署。
2. 针对老微服务的AWS版本改造迁移。
3. 实现S3文件存储。
4. 实现AWS日志挂载。

## 7. 其他

新业务功能开发。

1. 点赞+++++++++++++++++++++++++附近的人，点赞可以参考Mysql实战45里面的15的业务设计问题。(点赞系统，延伸到附近的人和互相关注方面)
2. 组团
3. 华瑞征信
4. 抽奖

   1. 接口，表
   2. 责任链
   3. 抽奖算法
5. 答题

   1. 接口，表，功能的设计
   2. 题库取题方法
   3. redis
6. 加签
7. f21改版 newwwwwwwwwwwwwwwww
8. 多线程。
9. 索引区分度。
10. 联合索引差距（索引的本质）。
11. 乐观锁，悲观锁，代码实现。
12. 举例子，A查数据库，把age=13改成了14，B查数据库，把age=13改成15。然后A发现age=15岁，技术上该怎么优化呢。

    1. 如果是先后发生的，从逻辑上来讲，我觉得这个流程很合理，没什么问题。我之前发现jd的购物车，就存在你说的这种现象。你用两台手机，第一台改了数量，第二台再改，第一台的数量就不作数了。
    2. 如果是同时发生的，那可以让先改的人获得锁，晚改的人失败，然后提示有人正在编辑年龄。又或者可以用带version的乐观锁，这样也会失败，然后返回对应的信息。
    3. 这个问题放在事务上，就是事务的隔离性。
13. 索引是不是越多越好。

    > 索引太多，表加锁就很复杂，容易死锁（或降低并发效率）
    >
14. spring事物。
15. transaction怎么保证多个事务一次性提交。
16. 事物内部怎么实现。
17. A服务调用B服务的时候超时了（比方说是转账），作为调用方，你不知道是成功还是失败，怎么处理呢。
    （比方说路由用了很久，就算你超时之后先查再处理，可能也会在处理之前）。
    （不管哪个服务调用，都有可能会有这种情况，不可能每个调用都用rabbitMQ吧）。

    > [微服务调用超时处理](https://www.jianshu.com/p/d68d572b0613)
    >
18. 你的job发消息，假设有100w数据要处理，每秒就10个。那么，如果你的job在跑，运维把你的机器重启了。
    你的job就中断了，你有什么措施可以优化这个方案呢。（我说了redis，他说为什么不用数据库）。
19. http路由分发怎么做（调用网关的地方用什么方式，比方配置或者参数什么的）。
20. 多实例情况下，调用失败了/超时了，怎么办。
21. 邮件打开率。
22. 思考你做的这些东西的架构。
23. 技术要深入了解，乐观悲观锁，虽然是概念，但是融会贯通，还是要多思考。
24. 做项目对自己要求高一点，多想几种设计方案。

分库分表也可以了解一下。

今天发现几个问题

1. 常量池不太明白，动态链接不知道是不是动态代理类似的东西
2. 类加载过程中，加载/验证/准备/解析，在准备这个环节中，会给static的变量赋初始值0，之后触发类构造器<clinit>()方法，给static变量赋值。而且初始值0这个过程是在方法区中的。
   但是，今天看操作数栈的时候，回顾了Inside the Java virtual machine，里面的例子里面，有一个非static的变量，也会给变量赋初始值0，但是这个时候
3. 类加载早就结束了?
4. 变量不是静态变量?
5. 理论上类构造器<clinit>()方法也已经触发了?

好像明白了，

1. 加载/验证/准备/解析 这个流程中的 准备，是把static的变量初始化到方法区
2. Inside the Java virtual machine里面的例子里面，是非static变量，所以没在准备过程中初始化，而是后来初始化成0，然后放在内存中
3. 然后类加载完之后，到初始化过程，static变量和非static变量（目前都是0），一起被赋值
4. 多线程变量是不是共享的，什么样的变量是多线程共享，什么是线程单独。
5. String,StringBuilder,StringBuffer
6. 数据库锁和事物的区别，事物什么时候会失败
7. 业务幂等(这个问题无语了，非业务幂等其实就是让前端传一个参数，醉了)

   > [面试阿里被问：“你的项目是如何处理重复请求/并发请求的？”](https://mp.weixin.qq.com/s?__biz=MzAxMjEwMzQ5MA==&mid=2448895276&idx=2&sn=5481eee82913a5023765f3dd5f461cc7&chksm=8fb57701b8c2fe178852e717ba4308d2c79639d887c4f47586b033b7fd0b07a6e624a587bb67&xtrack=1&scene=90&subscene=93&sessionid=1605693431&clicktime=1605693485&enterid=1605693485&ascene=56&devicetype=android-29&version=270014ab&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=Aq1ie%2BtDiQGkzSSNZCr%2BB8U%3D&pass_ticket=2It%2BeAOsIM3ngwvmKr4qsgTBkp6N4IRLSySk7JEw2ilEDQMsymAhtaEkZaWHeqxr&wx_header=1)
   >
   > 主要还是需要一个唯一标识，1-全局唯一标识，2-利用userId，请求参数等，造一个唯一标识
   >
8. redis分布式锁
9. cpu 100%

   1. top命令查看cpu消耗，找到特别多的那个进程。
   2. 根据进程id，找消耗最多的那个线程。(`top -Hp`)
   3. jstack命令查看进程日志，然后搜索线程id（16进制）
   4. 确认问题
   5. 待续
      [CPU占用100%排查过程 - 云+社区 - 腾讯云](https://cloud.tencent.com/developer/article/1400432)
10. 内存排查
11. AQS, countDownLatch
12. Synchronized

    1. 三种使用场景
       1. 修饰实例方法：锁实例对象。
       2. 修饰静态方法：锁class对象。
       3. 修饰代码块：锁代码块中的对象。
    2. monitor
       1. 同步代码：对象头关联monitor，monitor enter/exit，可重入，对应monitor里的count+1/-1。
       2. 同步方法：执行同步方法的时候，先判断是否有ACC_SYNCHRONIZED标志位，然后ACC_SYNCHRONIZED隐式调用monitor enter/exit。
    3. 升级
       1. 无锁
       2. 偏向锁：
          1. markword和栈帧的锁记录里面写自己的线程id，每次访问对比线程id，不一样的话就cas尝试替换。
          2. cas替换失败就升级。
       3. 轻量级锁
          1. 复制markword的内容到自己的栈帧的displaced markword。
          2. cas把markword改成指向自己的锁记录的指针。
          3. 自适应cas，失败就升级。
       4. 重量级锁
          1. 用互斥量实现，没获得锁的挂起。markword是指向互斥量的指针。
          2. 没获得锁的线程被包装成ObjectWaiter，放在Contention List的队首。
          3. Contention List中有资格成为候选的会移动到Entry List。
          4. 调用wait方法的放在Wait Set，被唤醒后放进Contention List。
          5. 线程释放锁之后，会从Contention List或EntryList中挑选一个线程等待唤醒（因为非公平）。
          6. 不过synchronized是非公平，可能有另外一个线程在被挂起前会cas尝试插队（入队之后都公平了，跟AQS其实一样）。
13. G1 CMS

    1. CMS
       1. 流程：初始标记，并发标记，重新标记，并发清除。
       2. 缺点：
          1. 占用处理器（这不是废话，哪种不占用，无病呻吟）。
          2. 因为是并发标记，所以要预留空间，空间不够要STW。
          3. 标记清除带来碎片。
       3. 并发阶段使用增量更新。
    2. G1
       1. 特点：不再硬性区分年轻/老年，分成很多个region，动态扮演eden/survivor/old/Humongous，大方向标记整理，细节上是复制。
       2. 问题：怎么处理跨region的引用。用remember set。
       3. 流程：初始标记，并发标记，最终标记，筛选回收。
       4. 缺点：内存和cpu负载高
       5. 并发阶段使用原始快照。
14. 工厂模式，单例模式，模板模式，责任链模式，创造者/建造者？代理模式
15. 线程消亡介绍 + 一个线程罢工的诡异事件（这个东西可以当作自己的一个案例），可以说不能盲目使用线程池，我们这里用了，只有一个线程，然后怎么怎么，就出错了。那么介绍的时候，要怎么说自己怎么解决这个问题呢，得思考一下。

    1. 线程池的三大问题：1. 不是先增加线程数，而是新任务直接入队列（有些场景不好用，例如tomcat就改造了）。2. 队列数量未知，很容易积压很多，需要一个监控。3. 无界队列很不合理。
16. Mysql

    1. 索引
    2. 锁
    3. 事务
17. 装饰者模式??????和代理模式啥区别

自我介绍：

你好，我叫bzq，今年32岁，工作七年。

13年在英国诺丁汉大学，信息技术专业，获得硕士学位。

2014年加入上海古鳌电子科技股分有限公司，任java工程师。
这是一家a股上市公司，主要从事银行金融机具的开发和生产。
例如点钞机，清分机，atm机等。我主要为这些设备提供pc端的支持。

2016年离职，加入群星金融，担任java后台研发工程师，任职至今。
群星金融是一个互联网金融平台，服务银行和需要融资的大型企业。
大型企业可以通过平台把自己的上下游的多笔应收账款打包在一起，向银行申请贷款。
在群星金融，我主要负责网站的后台开发及维护，
例如用户操作，通知发送，网关的建设等。

线程池方面，主要分为几点。

1. 几个主要参数。
2. 线程池的主要工作流程。
3.
