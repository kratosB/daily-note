1. 微信公众平台
    1. 微信菜单，oauth网页授权
    2. 微信账号和平台账号的整合关联
    3. 微信消息处理

2. zuul网关
    1. 路由功能
    2. 过滤器
    3. 负载均衡

3. 配置中心
    1. 微服务通过配置中心加载配置
    2. 热加载
    3. 加密
    4. 区分环境

4. 通知模块
    1. 模板增删改查
    2. 重构老的通道发送部分（兼容多通道，配比），新增腾讯云通道）
    3. 邮件埋点
    4. 场景发送 rabbitMQ
    5. 短链接

5. 用户/客户模块
    1. 微服务迁移（迁移成SpringBoot项目）
    2. 旧功能重构（例如版本改版，以及去重代码）
    3. 数据库查询缓存
    4. 新业务功能开发（抽奖/答题/点赞/星团/加签等等）

6. AWS改造迁移
    1. EC2，Beanstalk等AWS组件的配置部署
    2. 对老微服务的AWS版本改造迁移
    3. 实现s3文件存储
    4. 实现AWS日志挂载

7. 基础服务模块
    1. 附件上传
    2. pdf转图片
    3. excel解析
    4. 图片识别+发票验真（调用第三方接口）
    5. 验证码

13. pdf转图片+图片识别+发票验真
    1. 转图片（内存优化）
        1. https://www.cnblogs.com/firstdream/p/5536013.html
        2. https://www.cnblogs.com/dyllove98/archive/2012/04/24/2468771.html
        3. https://blog.csdn.net/win7system/article/details/53747032

1. 抽奖
(1)接口，表
(2)责任链
(3)抽奖算法

2. 点赞，星团，华瑞征信，加签，
(1)参与接口，表的讨论设计
(2)接口的实现
(3)解析excel表格，打包发送

3. 答题
接口，表，功能的设计
题库取题方法
redis

4. token

5. f21改版 newwwwwwwwwwwwwwwww
1. 读写分离
    1. redis key怎么设计（用hashmap数据类型是不是好一点，一个map代表一个表，里面是，主键->数据，或者，查询条件字段->数据）
    2. mysql更新之后remove缓存中对应的key
2. 有些数据，允许有一定的滞后和不精确。
比方booking页面上的一些细分类（经济型/舒适性/豪华型）后面都会跟上数量，如果每个用户登录的时候都去数据库查，不合适，因为用户可能并不需要非常精确的数据，可以很花资源。
可以做成job定时去跑，然后更新到缓存中，后面用户在主页的时候，直接去缓存中取用。这样可以快速返回，并节约数据库的资源。
用户如果点击了这个链接，进入相应的页面，再查出精确的数字，并更新缓存。
除此之外，job定时跑的时间也可以细分，有些不太会改变的数据，job就不用跑太频繁。比如之前做的时候，有xx类型的企业的数量。
3. 主动式缓存/被动式缓存
    1. 帖子里看到的，可以联系到2里面去，主动式是事先查，类似我上面2中提到的job，被动式就是查到更新缓存。参考帖子https://mp.weixin.qq.com/s/aQLX5w9EpgeDvJrhIlOFxw
    2. 这个帖子里还提到了缓存数据一致性的问题，提了两种方案。但是没说到我想的“更新之前先删除缓存”的方案，不太理解，可以研究一下。
    >今天突然想到了“更新之前先删除缓存”的坏处，在类似秒杀的场景下，如果用缓存做库存，每次秒杀卖出去1件都要更新db，然后删除缓存，那么缓存不就形同虚设了吗？
    >这种操作更适合读多写少的场景。**可能秒杀场景，就不适合使用数据库缓存一致，应该直接扣缓存**？
    >>今天看到一个讲缓存一致性的帖子，解决了我《更新之前先删除缓存”的方案》的疑惑。[缓存一致性问题怎么解决](https://mp.weixin.qq.com/s/aJ33A5O2PUcUOA34kL-Nzw)
    3. 这个帖子中，还有应对缓存穿透/击穿/雪崩的方案，感觉这个帖子里的东西，可以单独记录在redis目录下了。










1. 多线程。
2. 索引区分度。
3. 联合索引差距（索引的本质）。
4. 乐观锁，悲观锁，代码实现。
5. 举例子，A查数据库，把age=13改成了14，B查数据库，把age=13改成15。然后A发现age=15岁，技术上该怎么优化呢。
   1. 如果是先后发生的，从逻辑上来讲，我觉得这个流程很合理，没什么问题。我之前发现jd的购物车，就存在你说的这种现象。你用两台手机，第一台改了数量，第二台再改，第一台的数量就不作数了。
   1. 如果是同时发生的，那可以让先改的人获得锁，晚改的人失败，然后提示有人正在编辑年龄。又或者可以用带version的乐观锁，这样也会失败，然后返回对应的信息。
   1. 这个问题放在事务上，就是事务的隔离性。
6. 索引是不是越多越好。
    >索引太多，表加锁就很复杂，容易死锁（或降低并发效率）
7. spring事物。
8. transaction怎么保证多个事务一次性提交。
9. 事物内部怎么实现。
10. A服务调用B服务的时候超时了（比方说是转账），作为调用方，你不知道是成功还是失败，怎么处理呢。
（比方说路由用了很久，就算你超时之后先查再处理，可能也会在处理之前）。
（不管哪个服务调用，都有可能会有这种情况，不可能每个调用都用rabbitMQ吧）。
    >[微服务调用超时处理](https://www.jianshu.com/p/d68d572b0613)
11. 你的job发消息，假设有100w数据要处理，每秒就10个。那么，如果你的job在跑，运维把你的机器重启了。
你的job就中断了，你有什么措施可以优化这个方案呢。（我说了redis，他说为什么不用数据库）。
12. http路由分发怎么做（调用网关的地方用什么方式，比方配置或者参数什么的）。
13. 多实例情况下，调用失败了/超时了，怎么办。
14. 邮件打开率。

1. 思考你做的这些东西的架构。
2. 技术要深入了解，乐观悲观锁，虽然是概念，但是融会贯通，还是要多思考。
3. 做项目对自己要求高一点，多想几种设计方案。

分库分表也可以了解一下。

下次可以问一下，他们更想要招什么类型的人，有哪些标准。







今天发现几个问题
1. 常量池不太明白，动态链接不知道是不是动态代理类似的东西
2. 类加载过程中，加载/验证/准备/解析，在准备这个环节中，会给static的变量赋初始值0，之后触发类构造器<clinit>()方法，给static变量赋值。而且初始值0这个过程是在方法区中的。
但是，今天看操作数栈的时候，回顾了Inside the Java virtual machine，里面的例子里面，有一个非static的变量，也会给变量赋初始值0，但是这个时候
1. 类加载早就结束了?
2. 变量不是静态变量?
3. 理论上类构造器<clinit>()方法也已经触发了?

好像明白了，
1. 加载/验证/准备/解析 这个流程中的 准备，是把static的变量初始化到方法区
1. Inside the Java virtual machine里面的例子里面，是非static变量，所以没在准备过程中初始化，而是后来初始化成0，然后放在内存中

2. 然后类加载完之后，到初始化过程，static变量和非static变量（目前都是0），一起被赋值




今天发现的问题，注解这一块好像不是很明白，可以搜一下怎么自己写注解，怎么看源码？









1. 多线程变量是不是共享的，什么样的变量是多线程共享，什么是线程单独。
2. String,StringBuilder,StringBuffer
2. 数据库锁和事物的区别，事物什么时候会失败
3. 业务幂等(这个问题无语了，非业务幂等其实就是让前端传一个参数，醉了)
    >[面试阿里被问：“你的项目是如何处理重复请求/并发请求的？”](https://mp.weixin.qq.com/s?__biz=MzAxMjEwMzQ5MA==&mid=2448895276&idx=2&sn=5481eee82913a5023765f3dd5f461cc7&chksm=8fb57701b8c2fe178852e717ba4308d2c79639d887c4f47586b033b7fd0b07a6e624a587bb67&xtrack=1&scene=90&subscene=93&sessionid=1605693431&clicktime=1605693485&enterid=1605693485&ascene=56&devicetype=android-29&version=270014ab&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=Aq1ie%2BtDiQGkzSSNZCr%2BB8U%3D&pass_ticket=2It%2BeAOsIM3ngwvmKr4qsgTBkp6N4IRLSySk7JEw2ilEDQMsymAhtaEkZaWHeqxr&wx_header=1)
    >
    >主要还是需要一个唯一标识，1-全局唯一标识，2-利用userId，请求参数等，造一个唯一标识



数据库索引优化（可以看一下实战45讲的索引部分，还有order部分）
数据库锁，事务
偏向锁，轻量锁，重锁





新增一个点，今天排查问题的时候。发现一个数据库主键冲突，多service创建主键的时候的问题。
现有的方法是 业务码（比方说SO） + 设备号（比方说0，1，2，每个机器不一样）+时间戳精确到秒后三位。
每次存下上次的id，下次来了之后对比是否相等。如果id相等，则在后面+一个count（单机环境没问题）。如果不相等，直接用新的。
今天的问题是，serviceId没配，所以两台机器id冲突了。