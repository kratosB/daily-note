# [如何选择分布式事务解决方案？](https://mp.weixin.qq.com/s/2AL3uJ5BG2X3Y2Vxg0XqnQ)

## 理论

1. 一致性（C）、可用性（A）、分区容错性（P）不能同时满足。
2. BASE：基本可用（Basically Available），软状态（Soft state），最终一致性（Eventually consistent）

## XA Specification

### 2PC

1. 流程：
    1. 预备阶段：
        1. TM记录日志，
        2. 向RM询问操作（RM预留资源，枷锁，执行但不提交）
        3. TM收集RM的反馈，记录日志。
    2. 执行
        1. 根据RM反馈，发起事务提交或回滚。
2. 一致性：
    1. 最终一致性。
    2. 强隔离性。
3. 优点：
    1. 资源层面的分布式，业务入侵很低。
4. 缺点：
    1. 锁很重，阻塞时间长。吞吐量小。死锁概率大。
    2. 执行只是下达执行命令，过程错误了会一直重试。
    3. 脑裂（执行阶段，发送执行指令之后挂了，并且只有部分RM收到执行指令）

### 3PC

1. 2pc的进阶版，把2pc的预备阶段，拆分成了询问+准备。
2. 询问是确认资源和链接是否正常。
3. 准备是锁资源等操作，这里才开始阻塞，粒度更小。
4. 3pc还引入了超时。
5. 基本没有框架实现。

### TCC

1. 核心思想：
    1. 补偿。需要每个应用提供try，confirm，cancel三个接口。
    2. 事务发起者和参与者都要记日志，如果挂了，根据日志提交/回滚。
2. 流程：
    1. try：业务检查，预留资源。
    2. confirm：如果所有try都成功了，那就调用confirm（不做任何业务检查，仅仅使用预留的资源执行业务操作，如果失败会一直重试）。
    3. cancel：如果try失败，调用cancel补偿（取消执行业务操作，释放预留的资源，如果失败会一直重试）。
3. 一致性：
    1. 最终一致性。
4. 优点：
    1. 锁粒度小，吞吐量大。
5. 缺点：
    1. 代码入侵很重，开发成本高。
    2. 要允许空回滚，幂等，防资源悬挂等操作。

## saga（事务链）

1. 核心思想：
    1. 链式+补偿。
2. 流程：
    1. 把一个分布式事务，拆成一组本地事务组成的事务链。
    2. 链条中的每个事务，都有一个对应的反向事务。
    3. 按顺序执行，全部执行完，就释放资源。
    4. 执行出错，就反向执行反向事务回滚。
3. 一致性
    1. 最终一致性。
    2. 不保证隔离性。
        1. 本地事务提交之后，其他事务就可见了。
        2. 如果其他事务也提交了，那么补偿就可能会失败。
        3. 需要从设计上规避，
4. 优点：
    1. 对业务入侵低。
    2. 没有大长锁。吞吐量高。
    3. 适合流程较长的业务。例如微服务事务。
5. 缺点：
    1. 业务实现要求高。
        1. 允许空补偿。
        2. 幂等。
        3. 防资源悬挂
    2. 隔离性问题。
6. TCC和SAGA的区别：
    1. saga是不完美补偿。会有痕迹。（相当于insert之后delete）
    2. TCC是完美补偿。（相当于撤销commit）

## 基于消息的分布式事务

1. 一致性：
    1. 最终一致性。
    2. 不保证隔离性。
2. 优点：
    1. 方法之间解耦，吞吐量好。
3. 缺点：
    1. 对MQ要求高。
    2. 对业务入侵大。
    3. 不接受回滚。
4. 场景：适用于一致性敏感度低的场景。
5. 回滚需要下游回调上游。（1:1还算简单，1:N，N之中的一个出错了，回调1，1还要协调N的其他几个，就很麻烦）

### 基于事务消息的方案

1. 流程：
    1. 本地发送事务消息给MQ收到，MQ持久化并标记prepare。
    2. 本地等待MQ的ack，没收到ack就取消事务，收到ack就执行事务。
    3. 本地给MQ发送新消息（执行结果）。（这一步可能会失败，所以要给MQ提供一个查询接口。）
    4. MQ收到之后，处理消息（更改消息状态并发送/删除消息）。失败会不断重发。
    5. 参与者收到消息，执行事务，返回ack。（如果没成功，就不返回ack，MQ继续重发）
    6. MQ收到ack，删除消息。

### 基于本地消息的方案

1. 流程
    1. 本地事务写库的时候写两份数据（本地数据+MQ消息数据（待发送））
    2. job扫库找（待发送）数据发给MQ。
    3. MQ返回ack给job，job修改数据库（待发送->发送完成）
    4. MQ给下游推送消息，失败重发。
    5. 下游执行，返回ack
    6. MQ收到ack，删除消息。

## 最大努力通知型分布式事务

1. 思想：定期校验机制对事务兜底。
2. 流程：
    1. 本地事务完成之后，给MQ发送消息。（发送失败定期重新发送）
    2. 消息订阅方处理消息。（处理失败定期重新处理）
    3. 消息处理方回调上游更新状态。
3. 一致性：
    1. 最终一致性。
    2. 无隔离性。
4. 优点：
    1. 业务入侵低。
    2. 简单。
5. 缺点：
    1. 一致性敏感度低，不隔离。
6. 场景：适合于对最终一致性敏感度比较低、业务链路较短的场景，比如跨平台、跨企业的系统间的业务交互。

## 分布式中间件

## Seata

seata支持tcc和saga，不过seata的tcc对业务0入侵，叫做AT（Automatic Transaction）模式。

深入数据库，生成回滚日志（类似undo log），作为回滚的基础。

>失败需要人工介入

## 总结

分布式环境很难实现ACID，为了高可用和高吞吐，一般不追求强一致性，一般追求最终一致性。

把提供强一致性的事务称之为刚性事务，把提供最终一致性的事务称之为柔性事务。刚性事务可以完全满足 ACID 四个特性，柔性事务对事务的 ACID 特性的支持情况如下：
1. 原子性：完全支持。
2. 一致性：只提供最终一致性支持。
3. 隔离性：不完全保证，通常为了系统的吞吐和性能，会一定程度上放弃对隔离性的要求。
4. 持久性：完全支持。

### base理论

BASE 理论，是对 CAP 理论的延伸，是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

在系统选择分布式方案时，可以根据对一致性的要求进行选择，业务上有强一致性要求的场景时，优先考虑 XA 规范的两阶段提交；业务上只需要最终一致性的场景时，可以在根据具体场景在柔性事务方案中进行选择。

# 引用
1. [如何选择分布式事务解决方案？](https://mp.weixin.qq.com/s/2AL3uJ5BG2X3Y2Vxg0XqnQ)
2. [令人头疼的分布式事务，1次讲明白！](https://mp.weixin.qq.com/s/Moqp8DnOYy4lHQsw-iLC_A)
3. [面试官：聊聊分布式事务，再说说解决方案！](https://mp.weixin.qq.com/s/QpOwudYMY1HMRpU6SIXjzA `这里面说saga新，业界没有实现，就很离谱？`)

