# 附近的人（方案和代码）

## 基本套路和方案

1. Mysql外接正方形
2. MySQL + GeoHash
3. Redis + GeoHash
4. MongoDB + 2d索引

### Mysql外接正方形

1. 假设要找500范围内的人，直接取半径500的元比较难，可以取一个1000*1000的正方形，然后过滤掉4个角落。
2. 优点：简单，只要建一张表存下用户的经、纬度信息即可。
3. 缺点：需要大量的计算两个点之间的距离，非常影响性能。
4. 实现：
    1. sql建表（id,name,longitude,latitude）。
    2. 获取正方形的四个点的坐标
    3. 数据库查询对应数据，直接用`longitude BETWEEN ${minlng} AND ${maxlng}`和`latitude BETWEEN ${minlat} AND ${maxlat}`就可以。
       >需要的话还可以建longitude和latitude的联合索引。
    4. 遍历数据库中查询到的点，计算距离，去掉大于500的（正方形被圆形切掉的4个角），剩下排序。

### MySQL + GeoHash

1. 在存用户位置信息时，根据用户经、纬度属性计算出相应的GeoHash字符串。查询的时候，数据库通过`WHERE geohash Like ‘geocode%’`来查询附近用户。
    >GeoHash算法就是把2维的经纬度，转换成一个一维的数据，根据`geohash码长度`来判断精度。1位的精度是5000km，12位的精度是1.9cm*3.7cm。
2. 优点：思路和使用更加简单。
3. 缺点：GeoHash算法将地图分为一个个矩形，对每个矩形进行编码，得到GeoHash字符串。有可能当前的点与邻近的点很近，但恰好分别在两个区域，就会搜不到。
    >为了避免类似邻近两点在不同区域内，我们就需要同时获取当前点所在区域附近8个区域的GeoHash码，一并进行筛选比较。
4. 实现：
    1. sql建表（id,name,longitude,latitude,geo_code）。
    2. 根据用户经、纬度信息，在指定精度后计算用户坐标的GeoHash码。
    3. 获取到用户周边8个方位的GeoHash码。
    4. 在数据库中搜索用户，最后过滤掉超出给定距离(500米内)的用户。

### Redis + GeoHash（本质上跟上面一个方法没什么区别，就是效率略高一点）

1. 自Redis 3.2开始，Redis基于geohash和有序集合Zset提供了地理位置相关功能。
    >redis增加了`GEOADD`,`GEOPOS`,`GEORADIUS`等命令来实现这些功能。
2. 优点：gps这类数据属于读多写少的情况，如果使用redis来实现附近的人，效率比较高，集成也比较简单，而且还支持对距离排序。
3. 缺点：结果存在一定的误差，要想让结果更加精确，还需要手动将用户中心位置与其他用户位置计算距离后，再一次进行筛选。
4. 实现：
   1. 添加用户坐标信息到redis（GEOADD），redis会将经纬度参数值转换为52位的geohash码。
   2. Redis以geohash码为score，将其他信息以Zset有序集合存入key中。
   3. 通过调用GEORADIUS命令，获取指定坐标点某一范围内的数据。
   4. 因geohash存在精度误差，剔除超过指定距离的数据。

### MongoDB + 2d索引

跟上面的类似，没仔细看，略

## 引用
>1. [Java中“附近的人”实现方案讨论及代码实现](https://blog.csdn.net/qq_33619378/article/details/103604145?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control)
>2. [4种“附近的人”实现方式](https://blog.csdn.net/qq_26545503/article/details/106461821)