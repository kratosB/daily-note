1. Java基础
   1. volatile关键字底层原理
   2. 线程池各个参数含义
   3. lock、Synn区别
   4. ReentrantLock锁公平与非公平实现、重入原理
   5. HashMap扩容时机（容量初始化为1000和10000是否触发扩容）、机制、1.7与1.8的差异
   6. ConcurrentHashMap1.7、1.8的优化与差异，size方法实现差异
   7. ThreadLocal原理与风险、为什么会内存泄露
   8. 阻塞队列的用途、区别
   9. LinkedBlockingQueue对列的add、put区别，实际过程中如何使用
   10. 悲观锁、乐观锁、自旋锁的使用场景、实现方式、优缺点
   11. Class.forName、loanClass区别；
   12. 线程生命周期、死锁条件与死锁避免、状态转换关系（源码级别）；
   13. String intern方法；
   14. cas的优缺点与解决方案、ABA问题；
2. JVM相关
   1. CMS垃圾回收的碎片解决方式
   2. 常用的垃圾回收器
   3. JVM垃圾回收器CMS的优缺点、与G1的区别、进入老年代的时机
   4. JVM内存模型
   5. JVM调优思路
   6. GC Root、ModUnionTable
   7. 偏向锁、轻量级锁、重量级锁底层原理、升级过程
   8. jmap、jstat、top、MAT
   9. CMS与G1对别
   10. GC Root、ModUnionTable；
3. Redis相关
   1. Redis高性能原因
   2. Redis的部署模式
   3. RedisCluster底层原理
   4. Redis持久化机制
   5. 缓存淘汰机制
   6. 缓存穿透、缓存雪崩、缓存击穿发生场景与解决方案
4. SQL相关
   1. MyBatis拦截器的用途
   2. MyBatis动态SQL原理
   3. 分库分表方案设计
   4. MySQL怎么解决幻读、原理（源码级别）
   5. Gap锁的作用域原理
   6. RR、RC区别
   7. MySQL默认的事务隔离级别、Oracle默认的事务隔离级别
   8. MySQL为啥使用B+树索引
   9. redo log、binlog、undo
   10. log写入顺序、分别保证了ACID的什么特性
   11. 数据库乐观锁
   12. MySQL优化
   13. MySQL底层原理
5. Spring相关
   1. @Bean注解、@Component注解区别
   2. Spring Aop原理
   3. @Aspect和普通AOP区别
   4. 自定义拦截器和Aop那个先执行
   5. web 拦截器
   6. DispatchServlet原理
6. Dubbo相关
   1. Dubbo负载均衡、集群容错
   2. Dubbo SPI机制、Route重写使用场景
   3. Dubbo RPC底层原理
   4. 全链路监控实现原理
7. 分布式相关
   1. 分布式锁的实现方式
   2. 漏斗算法、令牌桶算法
   3. 事务最终一致性解决方案
   4. SLA
   5. 分布式事务实现方式与区别
   6. Tcc Confirm失败怎么办？
   7. 分布式锁的各种实现方式、对比
   8. 分布式ID的各种实现方式、对比
   9. 雪花算法时钟回拨问题与应对方案
   10. 红锁算法
8. 设计模式 
   1. 常用的设计模式
   2. 状态模式
   3. 责任链模式解决了什么问题
   4. 饿汉式、懒汉式优缺点、使用场景
   5. 模板方法模式、策略模式、单例模式、责任链模式
9. Zookeeper
   1. Zookeeper底层架构设计
   2. zk一致性
10. MQ
   1. Kafka顺序消息
   2. MQ消息幂等
   3. Kafka高性能秘诀
   4. Kafka高吞吐原理
   5. Rocket事务消息、延时队列
11. 计算机网络
   1. 浏览器输入一个url发生了什么
   2. Http 1.0、1.1、2.0差异
   3. IO多路复用
   4. TCP四次挥手过程、状态切换
   5. XSS、CRSF攻击与预防
   6. 301、302区别
12. Tomcat
   1. Tomcat大概原理
13. 代码
   1. 手写发布订阅模式
   2. 大数（两个String)相加
14. 场景问题
   1. 打赏排行榜实现
   2. 高并发下的请求合并
   3. CPU 100%处理经验
   4. 短链系统设计
   5. 附近的人项目实现
   6. 10w个红包秒级发送方案
   7. 延时任务的实现方案与优缺点对比




1. private修饰的方法可以通过反射访问，那么private的意义是什么
   1. private是一种规范，而不是安全手段。
2. Java类初始化顺序（其实结合类加载过程，能猜个大概）
   1. 静态代码块，静态变量（相同优先级，先后顺序）
   2. 普通代码块，普通变量
   3. 构造方法
3. 对方法区和永久区的理解以及它们之间的关系
   1. 方法区是虚拟机规范中的内容
   2. 永久区是java1.7的实现方式，1.8变成原空间。
4. 一个java文件有3个类，编译后有几个class文件
   1. 不管内部类，有几个class就有几个class文件
5. 局部变量使用前需要显式地赋值，否则编译通过不了，为什么这么设计
   1. 成员变量在类加载过程会有默认值。
   2. 局部变量有一个确定的适用范围，所以可以直接给值，不需要默认值，算是一种规范。
6. ReadWriteLock读写之间互斥吗
   1. 互斥。涉及AQS。
7. Semaphore拿到执行权的线程之间是否互斥
   1. 不互斥。
8. 写一个你认为最好的单例模式
   1. 懒汉，上来直接就创建，然后要用就去拿
   2. 饿汉，直到要用的时候才创建，其他人来拿
   3. 双重检查，加锁的饿汉
9. B树和B+树是解决什么样的问题的，怎样演化过来，之间区别
   1. 二分查找延伸出二叉树
   2. 二叉树延伸出平衡二叉树
   3. 磁盘问题，所以要层数少一点，延伸出多叉树
   4. b树到b+树
   5. b+树叶子还有指针。
10. 写一个生产者消费者模式
11. 写一个死锁
12. cpu 100%怎样定位
13. String a="ab";String b="a"+"b";a == b 是否相等，为什么
14. int a = 1;是原子性操作吗
15. 可以用for循环直接删除ArrayList的特定元素吗?可能会出现什么问题?怎样解决
16. 新的任务提交到线程池，线程池是怎样处理
17. AQS和CAS原理
18. synchronized底层实现原理
19. volatile作用，指令重排相关
20. AOP和IOC原理
21. Spring怎样解决循环依赖的问题
22. dispatchServlet怎样分发任务的
23. mysql给离散度低的字段建立索引会出现什么问题，具体说下原因