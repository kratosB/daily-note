# 线程消亡（非核心线程消亡，线程异常消亡）

1. execute会抛出异常，submit会把异常收集到future的返回里面。
2. 线程异常会被remove掉。
3. 不影响其他线程。
4. execute过程：
   1. 会触发addWorker，new一个worker，然后启动线程。
      > 注意，这个worker也是一个runnable，所以addWorker里面的`t.start`起的是这个worker这个线程。
   2. worker启动之后，会调用worker的run方法。然后调用runWorker方法。
   3. runWorker里面的`task.run()`才是执行丢进来的那个任务的地方。
5. submit（callable）过程：
   1. 包装RunnableFuture（FutureTask）。
   2. 跟execute的123一样。
   3. 这里的`task.run()`调用的是FutureTask的run。
   4. 这个run，里面有一个`c.call()`，就是调用callable的call的地方。
   5. `c.call()`后面，有一个`set(result)`，这里就是设置结果的地方。
   6. 这里面有两个点：
      1. 设置outcome。
         > future.get获取结果的时候，拿的就是这个outcome。
      2. 有一个`finishCompletion()`方法。
         > 里面有一个`done()`。  
         > 如果executor是ExecutorCompletionService，那么这个done就会把结果装进队列里。
6. 线程池种的线程，从队列中拿任务的方式，就跟`生产者-消费者`模式是一样的。
   > 如果队列中有好任务，就谁先做完谁去拿新任务。如果队列是空的，那就几个线程排队，来一个拿走一个。做完继续回来排队。  
   > 原里就是队列里的AQS中的条件队列（condition里面那个），在take任务的时候，被condition await住了。  
   > 这部分内容在ThreadPoolExecutor中的Worker里的runWorker里的getTask里。  
7. 线程回收的时候，先判超过核心线程书，然后判断断超时，然后重新循环一次，回收掉一个（不缺分核心非核心，没必要，而且会增加复杂度）。

## 引用
>1. [有的线程它死了，于是它变成一道面试题](https://mp.weixin.qq.com/s/wrTVGLDvhE-eb5lhygWEqQ)
>1. [有的线程它死了，于是它变成一道面试题](https://mp.weixin.qq.com/s/QTZ8_1ElOl2Cjx4-9Pc9Uw)
>1. [非核心线程怎么回收](https://mp.weixin.qq.com/s/1-h5AHhJYin9c9G_ozdJqQ `面试官一个线程池问题把我问懵逼了。`)