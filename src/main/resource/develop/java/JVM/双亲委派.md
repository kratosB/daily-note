# [我竟然被“双亲委派”给虐了](https://mp.weixin.qq.com/s/Q0MqcvbeI7gAcJH5ZaQWgA)

## 1. 什么是双亲委派？

1. 类加载器加载类的时候，要先委派上层的加载器加载。上层加载不了，才自己加载。
2. 第一层是bootstrap，第二层是extention，第三层是application，然后是用户自定义类加载器。
   1. bootstrap对应java home/bin下面的类。
   2. extention对应java home/bin/ext下面的类。
   3. 3application对应classpath下面的类。
   4. 用户自定义的对应任何自定义路径的类。

## 2. 为什么需要双亲委派，不委派有什么问题？

1. 防止类的重复加载。
2. 安全问题。防止被篡改的类被加载（替代了原有的类）。

## 3. "父加载器"和"子加载器"之间的关系是继承的吗？

1. 不是继承，是组合。
2. 子加载器中有一个classloader对象的引用，指向父加载器。
3. 子加载器的loadclass方法会先去判断是否有父类，然后再尝试用父加载器加载，父类加载失败，再用自身的findclass方法。

## 4. 双亲委派是怎么实现的？（答案基本同上）

1. 先判断类是否被加载过。
2. 没有加载则调用父加载器的loadClass()方法进行加载。
3. 父加载器为空则默认使用启动类加载器作为父加载器。
4. 父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

## 5. 我能不能主动破坏这种双亲委派机制？怎么破坏？

1. 可以，重写loadClass方法。

## 6. 为什么重写loadClass方法可以破坏双亲委派，这个方法和findClass（），defineClass（）区别是什么？

1. loadClass()就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。
   1. 想要破坏双亲委派，重写这个。
2. findClass()根据名称或位置加载.class字节码。
   1. 想要自定义类加载器，不破坏双亲委派，可以继承ClassLoader，重写findClass()。
3. definclass()把字节码转化为Class

## 7. 说一说你知道的双亲委派被破坏的例子吧

1. 在双亲委派出现之前。
2. JNDI、JDBC等需要加载SPI接口实现类的情况。
3. 为了实现热插拔热部署工具。
4. tomcat等web容器的出现。
5. OSGI、Jigsaw等模块化技术的应用。

## 8. 为什么JNDI，JDBC等需要破坏双亲委派？

1. 大概意思就是，DriverManager是跟加载器加载的。
2. 加载DriverManager的时候，需要加载classpath下的drivers。
3. 根加载器无法加载drivers，所以需要用其他加载器，破坏双亲委派。

## 9. 为什么TOMCAT要破坏双亲委派？

1. tomcat是一个web容器。可能部署多个应用。
2. 各个应用引用的类，版本可能不一样。
3. 双亲委派不允许重复加载，所以得破坏。
4. 为每一个应用准备自己的WebAppClassLoader，加载属于自己的类。

## 10. 谈谈你对模块化技术的理解吧！


## 引用
>1. [我竟然被“双亲委派”给虐了](https://mp.weixin.qq.com/s/Q0MqcvbeI7gAcJH5ZaQWgA)
>2. [我竟然被“双亲委派”给虐了](https://mp.weixin.qq.com/s/tYSm__QL-THtWi1iZBZnPA)