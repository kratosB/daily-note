# 第二章 Java内存区域与内存溢出异常

## 2.1 运行时数据区域

Java虚拟机会把运行过程中的内存分为几个不同的数据区。每个区域用途不统，创建和销毁的时间不统。主要包括以下几个数据区。

![Java运行时数据区](https://ws1.sinaimg.cn/large/006tNc79ly1fmk5v19cmvj30g20anq3y.jpg "Java运行时数据区")

### 2.1.1 程序计数器（Program Counter Register）

1. 程序计数器主要用来记录当前线程所执行的字节码的行号。Java虚拟机通过改变计数器的值来选取下一条要被执行的字节码指令。
2. 程序计数器是为**线程私有**的。为了能使多线程环境下，线程切换之后，每个线程都能恢复到正确的执行位置。
3. 如果线程在执行Java方法，计数器记录的是字节码行数，如果执行native方法，计数器的值是Undefined。
4. 这个内存区域是**唯一一个没有OutOfMemoryError的情况**的区域。

### 2.1.2 Java虚拟机栈（Java Virtual Machine Stacks）

1. 与程序计数器一样，Java虚拟机栈也是**线程私有**的。
2. 每个方法被执行的时候，都会创建一个**栈帧（Stack Frame）**，用于存储**局部变量表**，**操作数栈**，**[动态链接](https://blog.csdn.net/championhengyi/article/details/78760590 "即用到某个类再加载进内存")**，**方法出口**等信息。
    >动态链接：用到某个类再加载。
    >静态链接：类加载的过程就把符号引用转化为直接引用。
3. 局部变量表
    1. 存放了 - **编译期可知**的各种**基本数据类型**（boolean、byte、char、short、int、float、long、double）。
    2. 存放了 - **对象引用**（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
    3. 存放了 - **returnAddress类型**（指向了一条字节码指令的地址）。
    4. 局部变量表中的64位长度的**long和double**类型的数据会占用**2个局部变量空间**，其余的数据类型只占用**1个**。
    5. 局部变量表所需的内存空间**在编译期间完成分配**，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间**不会改变**局部变量表的大小。
4. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出**StackOverflowError**异常。
5. 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出**OutOfMemoryError**异常。

### 2.1.3 本地方法栈（Native Method Stack）

1. 本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
2. 在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。
3. 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

### 2.1.4 Java堆（Java Heap）

1. Java堆被所有**线程共享**。
2. 用于存放**对象实例**，几乎所有的对象实例都在这里分配内存。
3. 垃圾回收器管理的主要区域。
    1. 从分代回收角度来看，可以被分为：**新生代**和**老年代**（年轻带还能被分为**Eden空间**、**From Survivor空间**、**To Survivor空间**）。  
4. Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。
5. 既可以被设定成固定大小的，也可以是可扩展的。
6. 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出**OutOfMemoryError**异常。
7. TLAB(Thread Local Allocation Buffer)，多线程环境下，每个线程私有的分配缓冲区，这么分主要是为了方便垃圾回收和内存分配。

### 2.1.5 方法区（Method Area）

1. 方法区是各个**线程共享**的内存区域。
2. 它用于存储**已被虚拟机加载的类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据。
3. **方法区不等于永久代**，只是HotSpot虚拟机上，在垃圾回收上被归在永久代。但是1.8版本之后，**永久带**已经被移除了，使用了**元数据区**代替。
    1. JDK1.7之前，方法区位于**永久代（PermGen）**，永久代和堆相互隔离，永久代的大小在启动JVM时可以设置一个固定值，**不可变**。
    2. JDK1.7之中，永久代的部分数据就已经转移到Java Heap或者Native memory。但永久代并**没有完全移除**，譬如**符号引用**(Symbols)转移到了native memory；**字符串常量池**(interned strings)转移到了Java heap；**类的静态变量**(class statics variables)转移到了Java heap。
    3. JDK1.8之中，仍然保留方法区的概念，只不过实现方式不同。**取消永久代**，方法存放于**元空间(Metaspace)**，元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中。
        1. 移除了永久代（PermGen），替换为元空间（Metaspace）。
        2. 永久代中的（class metadata）转移到了（native memory）（本地内存，而不是虚拟机）。
        3. 永久代中的 字符串常量池（interned strings）和 类的静态变量（class statics variables）转移到了Java heap。
        4. 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）。
4. 这区域的内存回收目标主要是针对**常量池的回收**和对**类型的卸载**，不过比较难实现，效果也不好，但是很有必要。
5. 当方法区无法满足内存分配需求时，将抛出**OutOfMemoryError**异常。

### 2.1.6 运行时常量池（Runtime Constant Pool）

1. 运行时常量池是方法区的一部分，所以也是**线程共享**的。
2. Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池**（区别于**运行时常量池**）。
3. **常量池**用于存放**编译期**生成的各种**字面量和符号引用**，这部分内容将在**类加载后**进入方法区的运行时常量池中存放。
4. 一般来说，除了保存Class文件中描述的**符号引用**外，还会把翻译出来的**直接引用**也存储在运行时常量池中。
5. String类的**intern()方法**可以在运行期间将新的常量放入池中。
6. 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当方法区无法满足内存分配需求时，将抛出**OutOfMemoryError**异常。

> 用于存储编译期就生成的**字面常量**、**符号引用**、翻译出来的**直接引用**（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）
>> 举个例子，符号引用就是1. 类和接口的全限定名。 2. 字段名称和描述符。 3. 方法名称和描述符。

### 2.1.7 直接内存（Direct Memory）

1. 直接内存**并不是**虚拟机运行时数据区的一部分，**也不是**Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致**OutOfMemoryError**异常出现。
2. 本机直接内存的分配不会受Java堆大小限制，但是会收到本机总内存的限制，所以还是会出现**OutOfMemoryError**的异常。

## 2.2 对象访问

用一个例子来介绍一下，Java语言中，对象访问是怎么进行的。
这个例子不是《深入理解Java虚拟机》中的（这里面的例子太简单了，不够详细），是来自[《Inside the Java Virtual Machine》的第五章](https://github.com/kratosB/daily-note/blob/master/develop/java/JVM/Chapter%205%20of%20Inside%20the%20Java%20Virtual%20Machine.md#an-example-of-method-area-use)的。
> 这里的都是个人理解，有些操作和顺序还是存疑的。存疑部分用~~TTTTTTTTT~~标记。

    // On CD-ROM in file jvm/ex2/Lava.java
    class Lava {
    
        private int speed = 5; // 5 kilometers per hour
    
        void flow() {
        }
    }
    
    // On CD-ROM in file jvm/ex2/Volcano.java
    class Volcano {
    
        public static void main(String[] args) {
            Lava lava = new Lava();
            lava.flow();
        }
    }

1. Java虚拟机根据类名找到并读取Volcano.class文件。从类文件的二进制码中提取类Volcano的定义，**并将信息放入方法区**。
2. Java虚拟机通过解读方法区中的字节码，**调用main()方法**。
    > ~~这一步应该会在该线程（主线程）的堆栈中，创建一个适当大小的栈帧，然后把栈帧推送（push）到Java堆栈中。~~
3. 当Java虚拟机执行main()方法时，它**维护一个指向当前类（类Volcano）的常量池的指针**。
4. Java虚拟机**通过指针**进入Volcano的常量池，找到Lava类的符号引用。
5. Java虚拟机**检查方法区**，判断Lava类是否已经被加载。
    > 大多数Java虚拟机中，类是**单独加载**的，包括内部类，程序开始的时候**不会**把所有类都一起加载，等到**要用的时候**才加载。
6. 当Java虚拟机发现它没有加载Lava类，它会像加载Volcano一样加载Lava。
7. Lava加载完之后，Java虚拟机会把Volcano的常量池中的符号引用**替换成一个指针**，指向Lava的**类数据**。
8. 由于位于"="前的Lava是一个在main()方法中定义的变量，Java虚拟机会在main()方法的**栈帧中的局部变量表中**，添加一个引用。
    > ~~这里的引用应该是个初始值，类似null这种，就好比`Lava lava;`之后直接用lava中的方法，会抛出NPE，说明这时候lava的引用指向null。~~
9. Java虚拟机根据Volcano的常量池中的指针（**指向方法区中的Lava的数据**），确定要**在堆中**给Lava对象实例分配多少内存。
10. Java虚拟机**在堆上**为Lava对象实例分配合适的空间，并将Lava对象实例中的变量实例speed**初始化为0**。
    > * 如果Lava的父类（在这边是Object类），也有实例变量，那么它们也会被初始化成默认初始值。
    > * 这里还有一步，（存放在堆当中的）Lava对象实例中，Java虚拟机还会存放一个指向**Lava类的（存放在方法区中的）类型信息**的指针。
11. Java虚拟机把这个新的Lava对象实例的引用push到栈里（上面第8步的那个引用，有了自己的值）。
12. ~~Java虚拟机使用这个引用（main()方法的局部变量表中的Lava的引用），定位到堆区中的Lava对象实例，来初始化speed变量为它正确的初始值，5。~~
13. 
    1. 跟12步一样，Java虚拟机定位到Lava对象实例。
    2. Java虚拟机找到Lava的类型信息。（根据第10步中说过的，Lava对象实例中存放的，指向（存放在方法区中的）Lava类的类型信息的指针）
    3. Java虚拟机根据方法区中的类型信息，获取到flow()方法的字节码，并执行这个方法。
    > ~~跟上面第2步一样，这一步应该也会创建栈帧，并把栈帧推送到当前线程的堆栈上。~~

### 堆对象引用访问方式

Java虚拟机规范中只规定了指向对象得引用，并没有规定实现方式，所以不统的虚拟机可以有不同的实现方式，主流的方式有两种：**使用句柄**和**直接指针**。

#### 使用句柄

![使用句柄](https://www.artima.com/insidejvm/ed2/images/fig5-5.gif "使用句柄")

这种方法是把堆分成两部分：一个**句柄池**和一个**对象池**。对象引用是一个指向句柄池条目的本地指针。句柄池条目分成两个部分：一个**指向实例数据（对象池中的）的指针**，和一个**指向方法区中的类信息的指针**。

* 优点：这种设计可以让虚拟机**清理碎片变得更简单**。（堆内存整理的时候，什么都不用改，只要改句柄池里面的引用就行了）当虚拟机移动对象池中的对象时，它只需要使用对象的新地址更新一个指针：句柄池中的相关指针。
* 缺点：每次访问对象的实例数据，都得**解析两个指针**（~~对象引用指针+句柄池指针 / 还是要在句柄池两个指针间做判断？ 应该是前者~~）。

#### 直接指针

![直接指针](https://www.artima.com/insidejvm/ed2/images/fig5-6.gif "直接指针")

这种设计，堆不再被分为两个部分，让对象引用直接**指向一个合集**，合集包括对象实例数据，和指向方法区中的类数据的指针。

* 优点：每次访问对象的实例数据，**只需要解析一个指针**。
* 缺点：**移动对象更复杂**。清理内存碎片移动对象的时候，对象引用要更新（如果有好几个引用引用了这个对象，那就要更新好几个）。

> HotSpot使用直接指针的方式。

## 2.3 实战：OutOfMemoryError























