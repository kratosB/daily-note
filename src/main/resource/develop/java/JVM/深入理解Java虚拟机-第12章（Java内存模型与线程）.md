# 第十二章 Java内存模型与线程

1. 多任务原因：
    1. 计算机速度比通讯和存储快太多，大多数时间都花在磁盘IO，网络通讯和数据库访问，为了避免处理器大多数时间处于等待。
    2. 一个服务器对应多个客户端，需要多任务。
2. 每秒事务处理数（Transactions Per Second，TPS）是最重要的指标之一。

## 12.1 硬件的效率与一致性

1. 读写内存太慢了，所以需要**高速缓存**。
2. 缓存的使用：
    1. 将需要的数据复制到缓存中，让运算能快速进行，当运算结束后，再**从缓存同步**回内存中。
3. 缓存的**问题**：
    ![处理器，高速缓存，主内存交互](https://img-blog.csdn.net/20151107223057063 "处理器，高速缓存，主内存交互")
    1. **缓存一致性（Cache Coherence）**：多处理器系统中，每个处理器都有自己的高速缓存，同时共享同一主内存。当多个处理器运算涉及同一块内存时，可能导致各自的缓存数据不一致，那么同步到主内存时，以谁的缓存数据为准呢？
    2. 为了解决这个问题，在读写时要根据**协议**来操作（Java虚拟机可以借鉴这种方式），例如MSI，MESI，MOSI，Synapse，Firefly及Dragon Protocol等等。
4. 处理器还会对输入代码进行**乱序执行优化（Out-Of-Order Execution）**，Java虚拟机的即时编译器中也有类似的**指令重排序（Instruction Reorder）优化**。

## 12.2 Java内存模型

1. Java规范定义了一种Java内存模型（Java Memory Model，JMM）来屏蔽各种硬件和操作系统的访问差异。
    >在此之前，C和C++之类的语言直接使用物理硬件（或者说操作系统的内存模型），所以在不同平台上会有差异，导致不可用。

### 12.2.1 主内存与工作内存

1. Java内存模型规定了所有的**变量**都存储在**主内存**中。
    1. 这个变量，包括实例字段，静态字段，等共享变量（不包括线程私有的局部变量和方法参数）。
    2. 这个主内存，是虚拟机内存中的主内存（不是计算机中的主内存）。
2. 每个线程都有自己的私有的**工作内存**。
    1. 工作内存中保存了被该线程使用到的变量的主内存**副本拷贝**，线程对变量的操作（读取，写入）都必须在工作内存中进行，而**不能直接读写**主内存中的变量。
    2. 不同线程无法直接访问对方工作内存中的变量，线程间变量值传递通过主内存完成。
    3. 这里的主内存，工作内存，与堆，栈，方法区等，不是同一种划分规则。
        
        如果一定要对应起来，那从变量，主内存，工作内存的定义来看。主内存主要对应Java堆中对象的**实例数据部分**，而工作内存则对应**虚拟机栈中的部分区域**。
        
        从更低的层次来说，主内存就是**硬件的内存**。而为了获取更快的运行速度，工作内存可能回优先存储于**寄存器和高速缓存**中。

### 12.2.2 内存间交互操作

1. 主内存与工作内存之间具体的交互协议（即变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存），Java内存模型中定义了以下8种操作：
    1. **lock（锁定）**：作用于**主内存**的变量，把一个变量标识为一条线程**独占**的状态。
    2. **unlock（解锁）**：作用于**主内存**的变量，把一个**处于锁定**状态的变量**释放**出来，释放之后的变量才能被其他线程锁定。
    3. **read（读取）**：作用于**主内存**的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
    4. **load（载入）**：作用于**工作内存**的变量，把read操作从主内存中得到的变量值放入工作内存的**变量副本**中。
    5. **use（使用）**：作用于**工作内存**的变量，把工作内存中的一个变量**传递给执行引擎**，每当虚拟机遇到一个需要使用到**变量的值**的字节码指令时会执行这个操作。
    6. **assign（赋值）**：作用于**工作内存**的变量，把一个从执行引擎**接收到的值赋值**给工作内存的变量，每当虚拟机遇到一个**给变量赋值**的字节码指令时执行这个操作。
    7. **store（存储）**：作用于**工作内存**的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用。
    8. **write（写入）**：作用于**主内存**的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。
2. Java内存模型规定了执行上述操作时**必须满足**如下规则：
    1. 如果要把变量从主内存读取到工作内存，必须顺序执行read、load。如果要将变量从工作内存同步回主内存，必须顺序执行store、write。**只需要顺序，不需要连续**，可以试read a，read b，load a，load b。
    2. **不允许**read和load，store和write操作之一**单独出现**。
    3. **不允许**一个线程**丢弃**它的最近的**assign操作**（变量在内存中改变了之后，**必须同步**回主内存）。
    4. **不允许**一个线程无原因的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
    5. 一个新的变量**只能**才主内存中“诞生”，**不允许**在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，use前面必须有load，store前面必须有assign。
        >~~这里的assign和初始化，网上的贴子和文章有出入~~
    6. 一个变量，同一时刻，**只能被一条线程**对其进行lock操作，可以**多次**lock，但是对应也要有**多次unlock才能解锁**。
    7. 如果对一个变量执行**lock操作**，会**清空**工作内存中此变量的值，在执行引擎使用这个变量前，需要**重新执行**read和load操作初始化变量的值。
        >~~这里的assign和初始化，网上的贴子和文章有出入~~
    8. **没被lock**的变量无法被unlock。无法unlock一个被其他线程lock的变量。
    9. 对一个变量**执行unlock操作之前**，**必须**先把变量**同步**回主内存中（执行store和write）。

### 12.2.3 对volatile型变量的特殊规则

1. **volatile**是Java虚拟机提供的**最轻量级**的**同步机制**。
2. 变量被定义成volatile之后，具备两种特性：
    1. 保证变量对所有的线程的**可见性**。这里的可见性是指，当一个线程修改了这个变量的值，**新值**对于其他线程来说是可以**立即得知**的。
        >举个不同变量的例子：线程A修改了普通变量a，然后向主内存进行回写。线程B在线程A回写**完成之后**再从主内存读取变量a，a的值才会对线程B可见，否则不可见。
        
        这里存在一个误区，volatile变量在各个线程中**是一致的**，但是**并不是并发安全的**。
        
        volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中的volatile变量也可以存在不一致的情况，但是每次**使用前都要刷新**，所以执行引擎看不到不一致的情况，所以可以认为是一致的），但是Java里面的**运算并非原子操作**，导致volatile变量的运算在并发下一样是不安全的，下面是示例代码：
        ```java
        /**
         * volatile变量自增运算测试
         */
        public class VolatileTest {
        
            public static volatile int race = 0;
        
            public static void increase() {
                race++;
            }
        
            private static final int THREADS_COUNT = 20;
        
            public static void main(String[] args) {
                Thread[] threads = new Thread[THREADS_COUNT];
                for (int i = 0; i < THREADS_COUNT; i++) {
                    threads[i] = new Thread(new Runnable() {
        
                        @Override
                        public void run() {
                            for (int j = 0; j < 10000; j++) {
                                increase();
                            }
                        }
                    });
                    threads[i].start();
                }
                // 等待所有累加线程都结束
                while (Thread.activeCount() > 1) {
                    Thread.yield();
                }
                System.out.println(race);
            }
        }
        ```
        这段代码发起了20个线程，每个线程对race进行10000次自增，如果能正确并发，输出应该是200000，但是这个代码每次结果都不一样，不会输出200000。
        
        问题出在race++之中，我们用javap反编译这段代码之后，获取如下字节码。
        ```text
        public static void increase();
          Code:
           Stack=2, Locals=0, Args_size=0
           0:   getstatic       #13; //Field race:I
           3:   iconst_1
           4:   iadd
           5:   putstatic       #13; //Field race:I
           8:   return
          LineNumberTable:
           line 14: 0
           line 15: 8
        ```
        从上面的字节码很容易就分析出：当`getstatic`指令把race的值取到操作数栈顶时，volatile关键字保证了race的值是正确的，但是执行`iconst_1`和`iadd`这些指令的时候，其他线程可能已经把race的值变大了，而在操作数栈顶的数据就成了过期数据，所以`putstatic`就会把较小的race值同步回主内存。
        
        其实这个地方就算只有一个操作（一个操作也可能有好多个步骤），也不一定能保证原子性，所以volatile关键字就无法保证并发安全，仍然需要通过加锁（synchronized或JUC包中的原子类）来保证原子性。
        
        像下面这种情况，就很适合使用volatile变量来控制并发。
        ```text
        volatile boolean shutdownRequested;

        public void shutdown() {
           shutdownRequested = true;
        }

       public void doWork() {
           while (!shutdownRequested) {
               // do anything     
           }
       }
        ```
    2. volatile变量的第二个语义是**禁止指令重排序优化**（对应12.1中的第4条）。
    
        下面是一个例子：
        ```text
        int a=10 ;//1
        int b=20 ;//2
        int c= a+b ;//3
        ```
        在Java中，普通变量仅仅会保证在这个方法的执行过程中，所有依赖赋值结果的地方，都能**获取正确的结果**，但是不能保证变量赋值操作的顺序与代码中的**执行顺序一致**。就像上面这个例子，一段特别简单的代码，理想情况下它的执行顺序是：1>2>3。但**有可能**经过JVM优化之后的执行顺序变为了 2>1>3。
        ```text
        private static Map<String,String> value ;
        private static volatile boolean flag = false ;
        
        //以下方法发生在线程 A 中 初始化 Map
        public void initMap(){
            //耗时操作
            value = getMapValue() ;//1
            flag = true ;//2
        }
        
        
        //发生在线程 B中 等到 Map 初始化成功进行其他操作
        public void doSomeThing(){
            while(!flag){
                sleep() ;
            }
            //do something
            doSomeThing(value);
        }
        ```
        假如上面的flag**没有**被volatile修饰，JVM可能会对1和2进行**重排**，导致value都还没有被初始化就有可能被线程B使用了。
        
        所以加上volatile之后可以**防止这样的重排优化，保证业务的正确性**。
3. 大多数场景下，volatile同步机制的性能要优于锁（synchronized和JUC包里的锁），是否选择volatile的依据是，**volatile的语义能否满足使用场景要求**。
    1. volatile**读**操作跟**普通变量**几乎没有区别。
    2. volatile**写**操作可能会慢上一些，因为它需要在本地代码中插入许多内存屏障（Memory Barrier或Memory Fence）指令来保证处理器**不发生乱序执行**。
4. **volatile**总结：
    
    假设T表示一个线程，V和W分别表示两个volatile变量，那么在进行read，load，use，assign，store和write操作时，需要满足如下规则：
    1. **一致性方面**：load之后才能use。只有在想要use的时候，才能load（想要load，目的必须是use）。所以线程T对变量V的use动作，可以认为是与load和read动作相关联的，**必须一起连续出现**（这个规则要求，在工作内存中，每次使用变量V之前，都**必须从主内存刷新最新的值**，用于保证自己能看到其他线程对变量V所作的修改（**保证一致性**））。
    2. **一致性方面**：assign之后才能store。只有在想要store的时候，才能assign（想要assign，目的必须是store）。线程T对变量V的assign动作，可以认为是与store和write动作相关联的，**必须一起连续出现**（这个规则要求，在工作内存中，每次修改变量V之后，都**必须立刻同步回主内存中**，用于保证其他线程可以看到自己对变量V所作的修改（**保证一致性**））。
    3. **禁止指令重排方面**：假设线程T对变量V有动作use_v，load_v和read_v（也可以是assign，store和write），对变量W有动作use_w，load_w和read_w。如果use_v优先于use_w，那么read_v也优先于read_w（这个规则要求，volatile修饰的变量**不会被指令重排**，保证代码的执行顺序与程序相同）。

### 12.2.4 对于long和double型变量的特殊规则

1. Java内存模型要求lock，unlock，read，load，assign，use，store和write这八个操作都具有原子性。
2. 但是对于64位的数据类型（long和double），允许将没有被volatile修饰的数据的读写操作划分为两次32位操作来进行，不过虚拟机一般还是会实现原子性。

### 12.2.5 原子性，可见性与有序性

#### 12.2.5.1 原子性（Atomicity）

1. Java的原子性就和数据库事务的原子性差不多，一个操作中要么全部执行成功或者失败。
2. 由Java内存模型直接保证的原子性变量操作包括**read，load，use，assign，store，write**这六个。大致可以认为，基本数据类型的访问读写是具备原子性的。
3. 如果应用场景需要更大范围的原子性，Java内存模型还提供了**lock和unlock**。不过用户无法直接调用lock和unlock，用户只能使用`monitorenter`和`monitorexit`，这两个字节码指令反映到Java代码中就是`synchronized`关键字，所以`synchronized`块之间的操作**具备原子性**。

#### 12.2.5.2 可见性（Visibility）

1. 可见性就是指，当一个线程**修改了共享变量**的值，其他线程能够**立即得知**这个修改。
2. Java内存模型通过变量修改后**将新值同步回主内存**，在变量读取前**从主内存刷新变量值**这种依赖主内存为传递媒介的方式来实现可见性的。
    >volatile变量的特殊规则，保证了新值能够立即同步到主内存，以及每次使用前立即从主内存刷新。
3. 除了**volatile**之外，还有两个关键字可以实现可见性，它们是**final**和**synchronized**。
    1. synchronized的可见性是由“对一个变量执行**unlock**（没有unlock的变量，其他线程访问不到）操作之前，**必须**先把变量**同步回主内存**中（执行store和write操作）”这条规则获得的。
    2. final应该就是说不可变，所以每个线程看到都一样吧。（原文里说了什么，构造器初始化完成，并且没有把“this”的引用传递出去，不太明白）

#### 12.2.5.3 有序性（Ordering）

1. Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的，如果在另一个线程观察这个线程，所有操作都是无序的。
    1. 前半句是指，线程内表现为串行的语义
    2. 后半句是指，指令重排序，和，工作内存与主内存同步延迟。
2. Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的**有序性**。
    1. volatile关键字本身就包含了禁止指令重排序的语义。
    2. synchronized则是由“一个变量在**同一个时刻**，**只允许一条线程**对其进行lock操作”这条规则获得的，这个规则决定了持有**同一个锁**的两个同步块，**只能串行进入**。
3. synchronized能满足**原子性，可见性，有序性**三种特性，但是有时候**性能影响**很大。
    >不过在多个线程层面，synchronized不保证有序性。

### 12.2.6 先行发生原则（happens-before）

1. 先行发生原则：Java内存模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，其实就是发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值，发送了消息，调用了方法，等。
2. 先行发生原则，是判断**数据是否存在竞争**，**线程是否安全**的主要依据。
3. 下面是Java内存模型自带的**先行发生关系**，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。
    >如果两个操作之间的关系不在此列，并且无法从下列规则中推导出来，那么它们就**没有顺序性保障**，虚拟机可以对它们进行随意的重排序。
    1. **程序次序规则（Program Order Rule）**：在一个线程内，按照程序代码顺序，书写在前面的操作，happens-before书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支，循环等结构。
        >这个“书写在前面”应该是指“语义上要先执行”的。猜的，不确定。
    2. **管程锁定规则（Monitor Lock Rule）**：一个unlock操作，happens-before后面**对同一个锁**的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
    3. **volatile变量规则（Volatile Variable Rule）**：对一个volatile变量的写操作happens-before后面对这个变量的读操作，这里的后面，同样是指时间上的先后顺序。
    4. **线程启动规则（Thread Start Rule）**：Thread对象的start()方法happens-before**此线程的每一个动作**。
    6. **线程终止规则（Thread Termination Rule）**：线程中的所有操作都happens-before**对此线程的终止检测**，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等手段检测到线程已经终止执行。
    7. **线程中断规则（Thread Interruption Rule）**：对线程interrupt()方法的调用happens-before被中断线程的代码**检测到中断事件的发生**，可以通过Thread.interrupted()方法检测到是否有中断发生。
    8. **对象终结规则（Finalizer Rule）**：一个对象的**初始化完成**（构造函数执行结束）happens-before它的**finalize()方法的开始**。
    9. **传递性（Transitivity）**：如果操作A happens-before操作B，操作B happens-before操作C，那么A肯定先行于C。
4. 举例介绍：
    ```text
    private int value = 0;
    
    public void setValue(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
    ```
    通过上面这个例子，介绍一下happens-before原则。假设存在线程A和线程B，线程A先（时间上的先后）调用了“setValue(1)”，然后线程B调用了同一个对象的“getValue()”，那么线程B收到的返回值是什么？
    1. 由于两个方法分别由线程A和线程B调用，不在一个线程中，所以**程序次序规则**不适用。
    2. 由于没有同步块，自然就不会发生lock和unlock，所以**管程锁定规则**不适用。
    3. 由于value变量没有被volatile关键字修饰，所以**volatile变量规则**不适用。
    4. 后面的**线程启动，终止，中断规则**，和**对象终结规则**也扯不上关系。
    5. 没有happens-before关系，所以也没有东西传递，**传递性**也不适用。
    因此这里是线程不安全的，虽然线程A在操作事件上先于线程B，但是线程B可能会得到0，也可能会得到1。
    
    解决方案：
    1. 使用synchronized关键字定义get/set方法，满足管程锁定规则。
    2. 使用volatile关键字修饰value变量，满足volatile变量规则。
5. 通过上面的介绍，得出一个结论：一个操作**时间上先发生**，不代表这个操作是**先行发生**。
    
    反过来，一个操作是**先行发生**，也未必是**时间上先发生**。一个经典的例子就是**指令重排序优化**。具体例子如下
    ```
    int i = 1;
    int j = 2;
    ```
    指令重排序优化之后，可以先执行`int i = 1`，也可以先执行`int j = 2;`，并不影响先行发生原则的正确性。
    
## 12.3 Java与线程

### 12.3.1 线程的实现

1. 每个Java.lang.Thread类的实例就代表了一个线程。
2. Thread类的所有关键方法都是Native的。

#### 12.3.1.1 使用内核线程实现

1. 内核线程（Kernel Thread， KLT）就是直接由**操作系统内核支持**的线程。
    1. 由内核完成线程切换。内核通过**操纵调度器**（**Scheduler**）对线程进行调度，并负责将线程的任务映射到各个**处理器**上。
    2. 每个内核线程都可以看作是内核的一个分身。这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫多线程内核。
    3. 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口：**轻量级进程（Light Weight Process，LWP）**。
        1. 轻量级进程就是我们通常意义上所讲的线程。
        2. 由于每个轻量级进程都由一个内核线程支持，因此**只有先支持内核线程，才能有轻量级进程**。
    4. 这种轻量级进程与内核线程之间的1：1关系称为一对一的线程模型。
    ![轻量级进程与内核线程](http://p1.pstatp.com/large/pgc-image/acea52f1adcd4f2d9ac9fa466b330924)
2. 优势：由于内核线程的支持，每个轻量级进程都成为一个**独立的调度单元**，即使有一个轻量级进程在系统调用中阻塞了，也**不会影响**整个进程继续工作。
3. 不足：
    1. 由于是基于内核线程实现的，所以各种进程操作，如创建，析构及同步，都**需要进行系统调用**。
        
        系统调用**代价相对较高**，需要在用户态和内核态中**来回切换**。
    2. 每个轻量级进程都需要一个内核线程的支持，因此轻量级进程**要消耗一定的内核资源**（如内核线程的栈空间），因此一个系统支持轻量级进程的**数量是有限**的。

#### 12.3.1.2 使用用户线程实现

1. 广义上讲，一个线程只要不是内核线程，就可以认为是用户线程。
    1. 按这么算，轻量级进程也属于用户线程，可是轻量级线程始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。
2. 狭义上讲，用户线程指的是**完全建立在用户空间的线程库上**，系统内核**不能感知**到线程存在的实现。
    1. 用户线程的建立，同步，销毁和调度，**完全在用户态中完成**，不需要内核的帮助。
    2. 如果程序实现得当，这种线程**不需要切换到内核态**，因此操作可以是**非常快速**而且**低消耗**的，也可以支持**更大的线程数量**（部分高性能数据库中的多线程就是由用户线程实现的）。
    ![进程与用户线程](http://p1.pstatp.com/large/pgc-image/c7df77b4a6b2454c85f4c9e9f6f60d69)
3. 优势：
    1. **不需要**系统内核支援，不需要切换到内核态，**速度快，消耗低**。
    2. 可以支持**更大的线程数量**。
4. 不足：
    1. **缺乏**系统内核的支援，所有线程操作都需要用户程序自己处理。
    2. 线程的创建，切换，调度都需要考虑，而且由于操作系统只把处理器资源分配到进程，那阻塞如何处理，多处理器的系统中如何将线程映射到其它处理器上，这类问题解决起来会**异常困难**。
    3. 像第二点说的那些问题，导致它非常复杂。

#### 12.3.1.3 混合实现

1. 在混合实现下，既存在用户线程，也存在轻量级进程。
    1. 用户线程还是完全建立在用户控件中，所以操作还是速度快，消耗低。同时还可以支持大规模用户线程并发。
    2. 操作系统提供支持的轻量级进程作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射。
    3. 用户线程的系统调用要通过轻量级线程来完成，降低阻塞的风险。
    ![用户线程与轻量级进程](http://p1.pstatp.com/large/pgc-image/e9c966a29cc24477af1c5cf4c4800578)
2. 优势：
    1. 速度快，消耗低。
    2. 支持更大线程数量。
    3. 可以使用内核提供的调度功能和处理器映射。
    4. 降低阻塞风险。

#### 12.3.1.4 Java线程的实现

1. 上面所说的3中实现方式是跟具体语言无关的实现，对应到java语言来看，java线程的实现使用的是哪种方式呢？这就需要看jdk的版本了。
2. JDK1.2之后：线程模型被替换为基于操作系统原生线程模型来实现—native
    * Windows版和Linux版都是使用一对一的线程模型来实现，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的。（Windows下有迁程包Fiber Package,Linux下也有NGPT来实现M:N模型，但是它们都没有成为主流）。
    * 在Solaris平台中，操作系统可以同时支持一对一和多对多的线程模型，因此在Solaris版的JDK中也对应提供了两个平台专有的虚拟机参数：-XX:+UserLwpSynchronization(默认值)和-XX:+UseBoundThreads来明确指定虚拟机使用的是哪种线程模型。

### 12.3.2 Java线程调度

1. 线程调度室指系统为线程分配处理器使用权的过程。主要调度方式有两种：
    1. **协同式（Cooperative Threads-Scheduling）线程调度**：
        1. 使用协同式调度的多线程系统，线程的执行时间**由线程本身来控制**。线程完成自己的工作之后，**主动通知系统**切换到另一个线程。
        2. **优点**：
            1. **实现简单**。
            2. 由于线程要把自己的事情干完后才会进行线程切换，切换操作多线程自己是可知的，所以**没有什么线程同步的问题**。
        3. **缺点**：
            1. 线程执行**时间不可控制**。
            2. 甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么**程序可能会一致阻塞**。
    2. **抢占式（Preemptive Threads-Scheduling）线程调度**：
        1. 使用抢占式调度的多线程系统，每个线程**由系统来分配**执行时间，前程的切换不由线程本身来决定。
            >Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身就没办法了。
        2. **优点**：
            1. 执行时间**可控**。
            2. 不会有**一个线程导致整个进程阻塞**的问题。
2. Java使用的线程调度方式是**抢占式调度**（1.7，1.8之后可能还有其他）。
3. 可以通过**设置线程优先级**，来“建议”系统给某些线程多分配一些执行时间。
    1. 当两个线程都处于Ready状态时，优先级越高的程序，**越容易**（**但是不一定**）被系统选择执行。
    2. Java的线程是被映射到系统的原生线程上来实现的，所以线程调度最终还是由操作系统说了算。虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与JAVA线程的优先级一一对应（java中的多个优先级可能映射到操作系统中变为同一个优先级，导致无法通过优先级设置影响线程的调度）。
    3. 优先级还有可能**被系统自行改变**。

### 12.3.3 状态转换

1. Java语言定义了5种进程状态，在任意时刻，一个进程只能有且仅有其中一种状态。
    1. **新建（New）**：**创建后尚未启动**的线程处于这种状态。
    2. **运行（Runnable）**：包括了操作系统线程状态中的**Running**和**Ready**，所以有可能时处于**执行状态**，也有可能时处于**等待分配状态**。
    3. **等待（Waiting）**：包含两种情况
        1. **无限期等待（Waiting）**：需要等待被其他线程显式地唤醒。
        2. **限期等待（Timed Waiting）**：带超时时间的等待，超时以后由系统自动唤醒。
    4. **阻塞（Blocked）**：线程因为某种原因未获得CPU使用权。
        >有可能是等待获取一个排他锁（等待其他线程释放锁），也有可能是IO之类的原因。
    5. **结束（Terminated）**：当前线程执行完毕。
    ![线程的状态转换](http://p1.pstatp.com/large/pgc-image/14a0ff2eedf04b2c8f0eb209a728641a)

# 参考资料

>1. [jvm主内存与工作内存](https://blog.csdn.net/zxh476771756/article/details/78685581)
>
>2. [你应该知道的 volatile 关键字](https://crossoverjie.top/JCSprout/#/jvm/volatile)
>
>3. [技术进阶：深入理解Java虚拟机，Java与线程](https://blog.csdn.net/qq_39662660/article/details/89005821)