# 可达性分析和G1垃圾回收

1. javaGC使用可达性分析。
2. 可达性分析中最重要的是并发标记。
3. 并发标记使用三色标记法。
   1. 黑色表示自己和儿子已经被扫描。
   2. 灰色表示自己被扫描，儿子没被扫描。
   3. 白色表示没被扫描
      标记阶段结束之后，白色的就是不需要的，会被回收掉。
4. 三色标记法有两个问题。
   1. 浮动垃圾：把死亡的对象标为存活。
   2. 对象消失：把存活的对象标为死亡。
5. 解决“对象消失”问题。
   1. CMS是基于**增量更新**来做并发标记的。
   2. G1则采用的是**原始快照**的方式。
6. 增量更新：黑色对象如果新增了引用，那么黑色变成灰色，重新扫描。
   >我个人理解，如果A这一轮引用了C，不管B对C的引用有没有删除，把A标记成灰色，重新扫描A。坏处是可能一直扫，一直扫。
7. 原始快照：并发标记阶段，删除引用的时候，把每次引用关系变化时旧的引用值记下来，然后把被引用的对象标成非白，可以杜绝“对象消失”，代价是可能会产生“浮动垃圾”，这是可以接受的。
   >我个人理解，本轮并发标记期间产生的垃圾（引用变动之后没人引用的对象），放在下一轮去标记，因为这一轮你不知道有没有人会用他。
   >> 假设（在这一轮并发标记中）B删除了对C的引用，那么不管C有没有（在这一轮中）被其他对象引用，都把它当作被引用的对象（因为很有可能你每次扫完，新的引用建立了，并发的情况下，你无法分辨是否被引用）。
8. G1分为初始标记(Initial Marking)，并发标记(Concurrent Marking)，最终标记(Final Marking)，筛选回收(Live Data Counting and Evacuation)。
9. 初始标记。
    1. 标记GC Roots能直接关联到的对象。
    2. 修改TAMS（Next Top at Mark Start）的值，让NextTAMS指向Top（PrevTAMS一开始指向Bottom）。
        >Bottom和Top之间，就是每个Region中被用掉的部分，Bottom是起点，Top是终点，随着用掉部分的增加往后移动。Top到底，就说明Region用光。
    3. PrevTAMS到NextTAMS这一段，就是这次GC（包括后面几个阶段）会扫的地方。
        >此时NextTAMS和Top是重叠的，因为初始标记是STW的，用户线程不会造新对象。
10. 并发标记。
    1. 从GC Roots开始对堆的对象进行可达性分析，递归扫描整个堆里的对象图，找出存活的对象。
        >扫描结果放在NextBitmap，黑色是存活，白色对应垃圾。
    2. NextTAMS与Top之间的对象，就是本次并发标记阶段用户线程新分配的对象，它们是隐式存活的。
        >因为本次GC不扫这个部分，下次GC再扫描。
    3. 当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
        >这个步骤，就是处理并发标记期间有引用变动的对象。
11. 最终标记。
    1. 是STW的。
    2. 并发标记的最后一个阶段是“当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。”，这个阶段也是并发的，用户线程还会继续工作，改变引用，需要一个STW的最终标记。
        >并发标记最后“处理并发标记期间有引用变动的对象”的期间，也有新的引用变动的对象，需要STW处理一下。不然无限套娃。
12. 清理阶段。（回收阶段这里没介绍，大概就是清除/复制算法吧）
    1. NextBitmap和PrevBitmap交换角色，老的NextBitmap变成PrevBitmap，新的NextBitmap是空的，留给下次标记使用。
    2. NextTAMS和PrevTAMS互换。
    3. 根据PrevBitmap标记老扫描区中（NextTAMS到PrevTAMS）需要被清除的部分。
13. 第二轮初始标记。
    1. NextTAMS再次指向Top，PrevTAMS保持不变（这次不是指向Bottom了，而是上次GC的终点）。
    2. 新的NextBitmap划空间，对应Bottom到NextTAMS。
        >其实跟之前第一次初始标记一样，之所以强调，是为了说明GC的范围应该是Bottom到NextTAMS，而不是PrevTAMS到NextTAMS。
14. 第二轮并发标记。
    1. 参考第一次标记的结果（应该就是PrevBitmap中已经标为垃圾的就不用再次扫了，省时间），再扫描Bottom到NextTAMS这一段，把扫描结果放在NextBitmap。
15. 第二轮清理阶段。
    1. NextTAMS变PrevTAMS，新的NextTAMS指向Bottom，之前的PrevTAMS没了。
    2. NextBitmap变成PrevBitmap，旧的PrevBitmap没了。
16. 之后第三轮第四轮就循环这么个操作。
17. G1把Region作为单次最小回收单元，每个Region都有一个回收价值（需要多少时间，能回收多少空间），G1会优先回收价值大的Region（而不是一次回收所有Region）。

## 引用
>1. [面试官:你说你熟悉jvm?那你讲一下并发的可达性分析](https://mp.weixin.qq.com/s/EgVPlOLArsWb86Kujykn3A)
>2. [G1回收器：我怎么知道你是什么时候的垃圾？](https://mp.weixin.qq.com/s/5BIFme6bmyOA0WbKOllbjw)
>3. [面试官：你回去等通知吧！](https://mp.weixin.qq.com/s/LrOKgDTMdQJ787L8IqqwSQ)