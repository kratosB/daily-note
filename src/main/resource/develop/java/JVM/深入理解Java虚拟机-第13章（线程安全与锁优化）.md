# 第十三章 线程安全与锁优化

## 13.1 线程安全

1. 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。
2. 大多数场景中，会弱化这个定义，把“调用这个对象的行为”限定为“单次调用”。

### 13.1.1 Java语言中的线程安全

#### 13.1.1.1 不可变

1. 在Java语言里（jdk1.5之后，即Java内存模型被修正之后），**不可变的对象，一定是线程安全的**。
2. 如果共享对象是一个**基本数据类型**，那么只要在**定义的时候使用final关键字**修饰它就可以保证它是不可变的。
3. 如果共享对象是一个**对象**，那么就需要**保证对象的行为不会对其状态产生任何影响**，才能保证它是不可变的。
    >例如java.lang.String，它是一个典型的不可变对象，我们调用它的substring()，replace()和concat()这些方法，都不会影响它原本的值，只会返回一个新构造的字符串对象。
4. 保证对象行为不影响自己状态的途径有很多，最简单的是，把对象中**带状态的变量都声明为final**，这样在构造结束只会，它就是不可变的。
    ```text
    private final int value;
    
    public Integer(int value) {
        this.value = value;
    }
    ```
    例如上面的代码，取自java.lang.Integer，它通过将内部状态变量value定义为final，来保证状态不变。

#### 13.1.1.2 绝对线程安全

1. 绝对的线程安全完全满足13.1中第一条的定义，“绝对”两个字，非常安格。
    >书上用Vector的例子说明了，不加synchronized的时候，会出问题，但是我亲测没有实现。

#### 13.1.1.3 相对线程安全

1. 相对的线程安全就是我们通常意义上讲的线程安全。它需要保证**对这个对象单独的操作是线程安全**的，我们在调用的时候不需要做额外的保障措施。
    >但是对于一些特定顺序的连续调用，可能需要在调用端使用额外的同步手段来保证调用的正确性。
2. Java语言中，大部分线程安全都是相对线程安全，例如Vector，HashTable，Collections的synchronizedCollection()方法包装的集合等。

#### 13.1.1.4 线程兼容

1. 线程兼容是指，**对象本身并不是线程安全的**，但是**可以通过在调用端正确地使用同步手段**来保证对象在开发环境中安全地使用。
2. 平常说一个类**不是线程安全的**，大多是这种情况。
3. ArrayList和HashMap等。

#### 13.1.1.5 线程对立

1. 不管调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

### 13.1.2 线程安全的实现方法

#### 13.1.2.1 互斥同步（Mutual Exclusion & Synchronization）

1. 互斥同步是最常见的一种**并发正确性保障手段**。
    1. **同步**是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条线程使用。
    2. **互斥**是实现同步的一种手段，临界区（Critical Section），互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。
2. 最基本的互斥同步手段就是**synchronized关键字**。
    1. synchronized关键字经过编译之后，会在同步块前后分别形成`monitorenter`和`monitorexit`这两个字节码指令。
    2. `monitorenter`和`monitorexit`这两个字节码都需要一个**reference类型的参数**，来指明锁定和解锁的对象。
    3. 如果没有指定参数，那么就根据synchronized修饰的实例方法还是类方法，去获取对应**对象实例**或者**Class对象**来作为锁对象。
    4. 执行`monitorenter`指令时，首先要**获取对象的锁**。如果对象没被锁定，或者当前线程已经拥有对象的锁，那么把锁的计数器加1。（所以synchronized同步块对同一条线程来说是可重入的，不会自己把自己锁死）
    5. 执行`monitorexit`指令时，会将计数器减1，当计数器是0的时候，锁就被释放了。
    6. 如果获取对象失败了，那么当前线程就要阻塞等待，直到对象锁被另一个线程释放。
    >Java线程是映射到操作系统的原生线程上的，如果要**阻塞或唤醒一条线程**，需要操作系统来帮忙完成，需要从**用户态转换到核心态（内核态）**，所以状态转换需要消耗很多处理器时间。所以**synchronized是一个重量级操作**。
3. 除了synchronized关键字，还可以使用java.util.concurrent包中的**重入锁**（**ReentrantLock**）来实现同步。ReentrantLock跟synchronized用法基本一样，多了一些高级功能：
    1. **等待可中断**：持有锁的线程长期不释放锁的时候，正在等待的线程可以选择**放弃等待**，处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。
    2. **可实现公平锁**：公平锁是指多个线程等待同一个锁的时候，**必须按照申请锁的时间顺序来依次获得锁**。
        >非公平锁不保证这一点，任何等待锁的线程都有机会获得锁。synchronized是非公平的，ReentrantLock默认也是非公平，需要配置。
    3. **锁可以绑定多个条件**：一个ReentrantLock对象可以同时绑定多个Condition对象，只需要多此调用newCondition()方法即可。
        >synchronized需要使用wait()，notify()或notifyAll()方法实现一个隐含的条件，而且，如果要和多于一个的条件关联，就不得不多添加一个锁。
4. **性能方面**，jdk1.5下，synchronized多线程环境吞吐量下降严重。但是jdk1.6及之后，其实二者几乎没有区别。
5. 优先使用synchronized。
6. 互斥同步最主要的**问题**是，进行线程阻塞和唤醒所带来的性能问题，所以也被称为**阻塞同步**。
7. 互斥同步也属于一种悲观的并发策略，总认为只要不加锁就会出错。

#### 13.1.2.2 非阻塞同步（Non-Blocking Synchronization）

1. 除了阻塞同步，我们还有另一个选择，基于冲突检测的**乐观并发策略**，被称为非阻塞同步。
    1. 先进行操作，如果没有其他线程争用共享数据，那就操作成功。
    2. 如果共享数据有争用，产生冲突，那就再进行其他的补偿（最常见的就是重试）。
2. 乐观并发策略有一个先决条件，需要**操作**和**冲突检测**这两个步骤**具备原子性**，所以需要硬件指令集的帮助（因为不用硬件，用互斥同步的话，就非阻塞失去意义了）。
    1. 硬件保证一个从语义上看起来需要多此操作的行为，只通过一条处理器指令就能完成。
        1. 测试并设置（Test-and-Set）
        2. 获取并增加（Fetch-and-Increment）
        3. 交换（Swap）
        4. 比较并交换（Compare-and-Swap）
        5. 加载链接/条件存储（Load-Linked/Store-Conditional，简称LL/SC）
        前三个是上世纪就早就有了的，后连个是现代处理器新增的。
    2. CAS指令需要三个操作数，分别是内存位置（V），旧的预期值（A），和，新值（B）。
    
        CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值。这整个处理过程，**是一个原子操作**。
    3. jdk1.5之后，Java才支持CAS操作。最常见的就是J.U.C包里面的整数原子类（AtomicInteger），其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作。
     
        我们用第12章中volatile变量的例子（证明volatile不具备原子性的例子）来演示一下。
        ```java
        import java.util.concurrent.atomic.AtomicInteger;
        
        /**
         * Atomic变量自增运算测试
         */
        public class VolatileTest {
        
            public static AtomicInteger race = new AtomicInteger(0);
        
            public static void increase() {
                race.incrementAndGet();
            }
        
            private static final int THREADS_COUNT = 20;
        
            public static void main(String[] args) {
                Thread[] threads = new Thread[THREADS_COUNT];
                for (int i = 0; i < THREADS_COUNT; i++) {
                    threads[i] = new Thread(new Runnable() {
        
                        @Override
                        public void run() {
                            for (int j = 0; j < 10000; j++) {
                                increase();
                            }
                        }
                    });
                    threads[i].start();
                }
                // 等待所有累加线程都结束
                while (Thread.activeCount() > 1) {
                    Thread.yield();
                }
                System.out.println(race);
            }
        }
        ```
        运算结果是
        ```text
        200000
        ```
        使用AtomicInteger之后输出了正确结果，都要归功于**incrementAndGet()方法的原子性**。
        
        原理就是，incrementAndGet()方法在一个**无限循环**中，不断尝试用一个比当前值大1的新值赋给自己，如果失败了，说明其他线程已经线完成了这个操作，那么就**再循环进行下一次操作，直到成功为止**。
    4. CAS的问题：
        1. 这种操作无法涵盖互斥同步的所有使用场景。
        2. 会有ABA（Compare的值原本是A，中间被变成了B，后来又变成了A，这时候你去compare的时候，发现没变，就做了相应操纵，实际上已经错了）的问题。
        3. 自旋空转太久消耗资源（13.2.1里面有）
        
#### 13.1.2.3 无同步方案

1. 要保证线程安全，不一定要同步。同步只是保障了共享数据争用时的正确性。有些方法不涉及共享数据，就不需要同步。有些代码天生就是安全的，简单介绍两类：
    1. **可重入代码（Reentrant Code）**：
        1. 也叫纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身）而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。（这段定义其实没太看懂）
        2. **特征**：不依赖存储在堆上的数据和公用系统资源，用到的状态两都是由参数中传入，不调用非可重入方法。
    2. **线程本地存储（Thread Local Storage）**：
        1. 共享数据代码放在同一个线程内执行。
        2. 使用ThreadLocal来实现变量线程独享。

## 13.2 锁优化

### 13.2.1 自旋锁与自适应自旋

1. **自旋锁**：如果物理机有**1个以上的处理器**，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的线程“**稍等一会儿**”，但**不放弃处理器的执行时间**，看看持有锁的线程是否很快就释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自选），这个技术就是**自旋锁**。
    >因为挂起线程和恢复线程的操作都需要转入内核态中完成，对系统的并发行歹来很多压力。有时候锁其实只持续很短的时间。
2. 自旋等待本身虽然避免了线程切换的开销，但它**占用了处理器时间**。因此，如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，只会**浪费处理器资源**。默认10次。
3. **自适应的自旋锁**：自适应意味着自旋的时**间不再固定**，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
    >* 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。
    >* 另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。

### 13.2.2 锁消除

1. **锁消除**：指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。
2. 锁消除的**主要判定依据**来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，**认为它们是线程私有的，同步加锁自然就无须进行**。
下面是一个例子：
```text
public String concatString（String s1，String s2，String s3）{
	return s1+s2+s3;
}
```
由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此Javac编译器会对String连接做自动优化。在jdk1.5之前，会转化为StringBuffer对象的连续append()操作，在jdk1.5及以后的版本中，会转化为StringBuilder对象的连续append()操作，变成如下的代码：
```text
public String concatString（String s1，String s2，String s3）{
	StringBuffer sb=new StringBuffer();
	sb.append(s1);
	sb.append(s2);
	sb.append(s3);
	return sb.toString();
}
```
每个StringBuffer.append（）方法中都有一个同步块(synchronized)，锁就是sb对象。虚拟机观察变量sb，很快就会发现它的动态作用域被限制在concatString（）方法内部。也就是说，sb的所有引用永远不会“逃逸”到concatString（）方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。

### 13.2.3 锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小。但是，如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

如13，2，2中的append()的例子就是这种情况，不需要每个append()都加锁，直接在外面加一个大锁就行了。

### 13.2.4 轻量级锁

1. 

### 13.2.4 偏向锁

# 参考资料

>1. [深入理解Java虚拟机之线程安全与锁优化](https://blog.csdn.net/striveb/article/details/86592303)
>
>
>
