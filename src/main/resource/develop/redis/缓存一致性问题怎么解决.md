# [缓存一致性问题怎么解决](https://mp.weixin.qq.com/s/aJ33A5O2PUcUOA34kL-Nzw)

## 1. 先删缓存，再更新数据库

1. 缺点：先删除缓存，数据库还没有更新成功，此时如果读取缓存，缓存不存在，去数据库中读取到的是旧值，缓存不一致发生。
2. 解决方案：
    1. 延时双删:为了避免更新数据库的时候，其他线程从缓存中读取不到数据，就在更新完数据库之后，再sleep一段时间，然后再次删除缓存。

## 2. 先更新数据库，再删除缓存

1. 缺点：更新数据库成功，如果删除缓存失败或者还没有来得及删除，那么，其他线程从缓存中读取到的就是旧值，还是会发生不一致。
2. 解决方案：
    1. 消息队列:先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性的效果。
        1. 缺点：
            1. 引入消息中间件之后，问题更复杂了，怎么保证消息不丢失更麻烦。
            2. 消息的延迟也会带来短暂的不一致性。（不过这个延迟相对来说还是可以接受的）
   2. 进阶版消息队列（binlog）：一般大公司本身都会有监听binlog消息的消息队列存在，可以借助监听binlog的消息队列来做删除缓存的操作。
        1. 优点：
            1. 不用你自己引入，侵入到你的业务代码中，中间件帮你做了解耦。
            2. 中间件的这个东西本身就保证了高可用。
        2. 缺点:
            1. 消息延迟的问题依然存在，但是相比单纯引入消息队列的做法更好一点。
                >而且在主从库的情况下，主从库之间的同步，本身就是靠binlog来实现的，这里缓存的延迟，充其量也就跟主从库之间的延迟差不多，应该可以接受。

## 3. 其他解决方案（设置缓存过期时间）

1. 操作：每次放入缓存的时候，设置一个过期时间，比如5分钟，以后的操作只修改数据库，不操作缓存，等待缓存超时后从数据库重新读取。
2. 缺点：
    1. 一致性不是很高。
    2. 如果数据更新的特别频繁，不一致性的问题就很大了。

>携程redis实例的帖子中，大部分讲的就是这种方法

## 注意事项：为什么是删除，而不是更新缓存？

1. 更新会导致浪费。举个例子：
   1. 如果数据库1小时内更新了1000次，那么缓存也要更新1000次，但是这个缓存可能在1小时内只被读取了1次，那么这1000次的更新有必要吗？
   2. 反过来，如果是删除的话，就算数据库更新了1000次，那么也只是做了1次缓存删除，只有当缓存真正被读取的时候才去数据库加载。

## 帖子之外的自己的一点思考

研究这个问题的时候，想到了“秒杀场景”。

1. 使用方法1的话，会频繁的删除/创建/删除/创建缓存，是不是也很吃资源？
2. 如果使用方法3，那会不会出现非常不一致导致的超卖？

所以秒杀的时候应该直接扣缓存，而不是数据库缓存一致？

可以关注下。

## 引用
>1. [缓存一致性问题怎么解决](https://mp.weixin.qq.com/s/aJ33A5O2PUcUOA34kL-Nzw)
>2. [缓存与数据库一致性如何解决？先操作数据库，还是缓存？](https://mp.weixin.qq.com/s/QWy64GY8rDImipkOAt1x5Q)