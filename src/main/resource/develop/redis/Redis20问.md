# [redis20问](https://mp.weixin.qq.com/s/7eat4HplDfMetaJdjUr9zg)

1. 什么是redis。
   1. 基于内存的字典服务，多用于缓存。
2. redis基本数据结构。
   1. String
      1. 数字用int。
      2. 非数字小于39字节的用embstr。
      3. 非数字大于39字节的用raw。
      4. 底层用sds
         1. len：记录buf中已经使用的长度
         2. free：记录buf中没用的元素的长度
         3. buf[]：存放元素的数组
   2. Hash
      1. key是hash的名字。（类似于HashMap xxx = new HashMap中的xxx）
      2. value是hash的内容（一个map），map才是java中hashMap类似的结构。
   3. List
      1. 有序的字符串。
      2. ziplist
      3. linkedlist
      4. 应用场景：消息队列，文章列表
   4. Set
   5. Zset
      1. 有序的set，应用场景：排行榜？用户点赞？
   6. Geospatial
      1. 附近的人
   7. Hyperloglog
   8. Bitmap
3. redis为什么这么快。
   1. 基于内存实现
   2. 高效的数据结构
      1. SDS动态字符串（各种空间换时间）
         1. len记录字符串长度，需要的话可以直接返回，不用遍历。
         2. SDS分配了额外空间，不用反复分配。
         3. SDS缩短的时候，不回收内存，只用free记录。后续要变长，直接使用free记录的空间，减少分配。
         4. c中用'\0'判断是否结束，SDS用len判断。
      2. 跳跃表
         1. 链表的基础上，增加多级索引，提升查找效率。
      3. 压缩列表
   3. 合理的数据编码
      1. String：如果存储数字的话，是用int类型的编码;如果存储非数字，小于等于39字节的字符串，是embstr；大于39个字节，则是raw编码。
      2. List：如果列表的元素个数小于512个，列表每个元素的值都小于64字节（默认），使用ziplist编码，否则使用linkedlist编码。
      3. Hash：哈希类型元素个数小于512个，所有值小于64字节的话，使用ziplist编码，否则使用hashtable编码。
      4. Set：如果集合中的元素都是整数且元素个数小于512个，使用intset编码，否则使用hashtable编码。
      5. Zset：当有序集合的元素个数小于128个，每个元素的值小于64字节时，使用ziplist编码，否则使用skiplist（跳跃表）编码。
   4. 合理的线程模型
      1. IO多路复用
      2. 单线程模型
         1. 避免cpu在上下文切换，以及锁的竞争
         2. 执行时间过长的大命令会造成阻塞。
         3. 6.0引入多线程，都是执行命令操作内存的仍然是单线程。
   5. 虚拟内存机制
      1. redis自建vm。
      2. vm会把冷数据交换到磁盘，热数据放在内存。
4. 缓存击穿，缓存穿透，缓存雪崩。
   1. 穿透
      1. 原因
         1. 非法请求。
         2. 数据误删。
         3. 业务设计不合理。
      2. 解决方案
         1. 在api入口进行校验，过滤非法请求。
         2. 设置空值缓存。
         3. 布隆过滤器。
   2. 雪崩
      1. 原因
         1. 数据集中过期，所有的请求都打到数据库上，压力过大。
         2. redis故障。
      2. 解决方案
         1. 设置不同的过期时间。
         2. redis集群。
   3. 击穿
      1. 热点key失效的时候，大量相同的请求直接打到数据库。
      2. 解决方案
         1. 热点key不过期。
         2. 互斥锁，让这些相同的请求只有一个打到数据库。单机用java锁，分布式用分布式锁。
5. 什么是热key问题，怎么解决。
   1. 原因：
      1. 请求太多。
      2. 请求过于集中。
   2. 解决方案
      1. redis集群扩容。
      2. 热key分散。
      3. 使用jvm本地二级缓存。
6. redis过期策略和内存淘汰策略。
   1. 过期策略。
      1. 定时过期，给设置过期时间的key创建一个定时器，过期直接删除。缺点太耗cpu。
      2. 惰性过期，查到这个key的时候，判断是不是过期，如果过期，就删除。缺点太占内存。
      3. 定期过期，每隔一段时间，扫描一部分key，如果是过期的，则删除。缺点，时间段和删除量不好设置。
   2. 内存淘汰策略。
      1. volatile-lfu：已设置过期时间的当中，最不频繁使用的删掉。
      2. volatile-lru：已设置过期时间的当中，最长时间没有使用的删掉。
      3. volatile-random：已设置过期时间的当中，随机闪。
      4. volatile-ttl：已设置过期时间的当中，最早过期的删。
      5. allkeys-lfu：所有key中，最不频繁使用的删掉。
      6. allkeys-lru：所有key中，最长时间没有使用的删掉。
      7. allkeys-random：所有key中，随机删。
      8. 直接报错。
7. redis常用场景。
   1. 缓存。
   2. 分布式锁。
      1. 数据量不大可以用数据库。数据量大了，影响数据库性能。
      2. redis setnx和lua，可以实现分布式锁。
   3. 排行榜。zset，可以add，increase，排序。
   4. 计数器。视频播放量，文章/网站阅读量，每次都要+1。频繁访问数据库不太行，redis天然支持+1，性能好。
   5. 共享session。
   6. 社交网络。
   7. 消息队列。
   8. 位操作。
8. redis持久化机制。
   1. RDB
      1. redis默认的持久化方式。
      2. 内存数据以快照的形式存在磁盘上。
      3. 在指定的时间间隔内，执行指定次数的写操作，就把内存中的数据快照写入磁盘。
      4. 优点：适合大规模数据恢复，如备份，全量复制。
      5. 缺点：没法实时持久化。（有可能会丢失数据）
   2. AOF
      1. 默认不开启。
      2. 用日志追加写文件的形式，记录每一个写操作。
      3. 优点：数据一致性完整性高。
      4. 缺点：文件可能会很大，恢复会很慢。
9. redis高可用
   1. 主从模式
      1. 主节点负责读写，从节点负责读，主从之间使用主从复制。
      2. slave第一次连接master，采用全量复制。（应该可以使用RDB和AOF）
      3. slave与master同步知乎，master的数据发生改变，就会触发增量复制。
      4. 缺点：master挂了，得手动把slave升级成master。而且应用方也得升级（比如写数据，要写新的master）
   2. 哨兵模式
      1. redis2.8正式提供sentinel（哨兵）来解决主从模式的问题。
      2. ----------------------------------没太看懂，需要看其他资料---------------------------------------
   3. 集群模式
      1. ----------------------------------没太看懂，需要看其他资料---------------------------------------
10. redis分布式锁，以及注意事项。
    1. 
11. redisson及其原里。
12. redlock算法。
13. redis跳跃表。
14. mysql和redis双写一致性。
    1. 先删缓存，再更新数据库。
       1. 缺点，更新之前又有人查了，那数据就不一致了。
       2. 方案，延迟双删。
    2. 先更新数据库，再删缓存
       1. 缺点
          1. 更新完了，删缓存失败，数据不一致。
          2. 有延迟。
       2. 方案
          1. job，消息队列来做，复杂+有延迟。
          2. binlog来做，延迟还是有，但是延迟很少，就跟mysql主从一样，能忍。
    3. 设置过期时间（最终一致性）
    4. 删缓存，而不是更新缓存。
       1. 因为更新了不一定会用上，白搞。
15. 为什么redis6.0之后改多线程。
16. redis事务机制。
17. redis的hash冲突。
18. 生成RDB期间，redis可以同时处理写请求吗？
19. redis底层使用什么协议。
20. 布隆过滤器。


# [Redis从入门到精通，至少要看看这篇](https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&mid=2655827270&idx=1&sn=38de87e1342c7d1fa16644c1b68a533c&chksm=bd74f8918a0371872c32a3bc463c151939324a4f0345ef05eea324d5ba4061e850aa2a1884eb&scene=21#wechat_redirect)

