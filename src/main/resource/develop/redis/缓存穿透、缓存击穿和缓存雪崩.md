## 缓存穿透

1. 现象：当用户在查询一条数据的时候，而此时数据库和缓存却没有关于这条数据的任何记录，而这条数据在缓存中没找到就会向数据库请求获取数据。它拿不到数据时，是会一直查询数据库，这样会对数据库的访问造成很大的压力。
2. 解决方案：
    1. 缓存空对象：就是把这个key缓存下来，value是一个空对象，然后返回给用户。以后每次查就用这个缓存。
        >需要设置过期时间，不然浪费空间
    2. 布隆过滤器：
        1. 原理就是hash，但是hash的冲突率比较大，所以用多组hash。就相当于给贴标签，贴一个标签（比如"男"）冲突率就比较高，结合多个标签，冲突率就很低了。
        2. 除此之外，还要把这个hash的池子搞大一点。也可以减少冲突。
        3. 用在数据库缓存这一块，应该需要提前把所有的数据库的数据初始化到布隆中（个人理解，没看到类似案例）。
        >我个人觉得用在数据库缓存这一块，初始化算是缺点（空缓存不需要初始化）。而且布隆复杂。

## 缓存击穿

1. 现象：在key缓存失效的时候，突然有大量有关这个key的访问请求，这样会导致大并发请求直接穿透缓存，请求数据库，瞬间对数据库的访问压力增大。
2. 解决方案：加锁只能让第一个请求进行查询数据库，然后把从数据库中查询到的值存储到缓存中，对于剩下的相同的key，可以直接从缓存中获取即可。
    1. 单机环境下，直接使用常用的锁即可（如：Lock、Synchronized等）。
    2. 分布式环境下使用分布式锁。

## 缓存雪崩

1. 现象：在某一个时间段内，缓存集中过期失效，如果这个时间段内有大量请求，而查询数据量巨大，所有的请求都会达到存储层，存储层的调用量会暴增，引起数据库压力过大甚至宕机。
2. 原因：
    1. redis突然宕机。
    2. 缓存集体过期。
3. 解决方案：
    1. redis高可用。
    2. 给缓存设置不同的过期时间，分散压力。
    3. 限流降级：缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量，对某个key只允许一个线程查询数据和写缓存，其他线程等待。
    4. 数据预热：在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key。

## 引用

>[关于Redis缓存，这3个问题一定要知道](https://mp.weixin.qq.com/s/4nIPXybQXkOzLI8tkHoZVg)
>[redis缓存穿透穿透解决方案-布隆过滤器](https://www.cnblogs.com/xuehao/p/13877261.html)
>[如何避免Redis缓存穿透-布隆过滤器](https://blog.csdn.net/qq_32261247/article/details/109376936)
>[面试官问：缓存穿透、击穿、雪崩，有哪些解决方案](https://mp.weixin.qq.com/s/C34Hj6wyPybN_u5Bumelcw)