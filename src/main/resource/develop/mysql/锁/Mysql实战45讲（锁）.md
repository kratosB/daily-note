
- [6，全局锁和表锁 ：给表加个字段怎么有这么多阻碍？](#6全局锁和表锁-给表加个字段怎么有这么多阻碍)
- [7，行锁功过：怎么减少行锁对性能的影响？](#7行锁功过怎么减少行锁对性能的影响)
- [8，事务到底是隔离的还是不隔离的？](#8事务到底是隔离的还是不隔离的)
- [20，幻读是什么，幻读有什么问题？（涉及gap锁）](#20幻读是什么幻读有什么问题涉及gap锁)
- [21，为什么我只改一行的语句，锁这么多？（涉及加锁规则）](#21为什么我只改一行的语句锁这么多涉及加锁规则)
   
## 6，全局锁和表锁 ：给表加个字段怎么有这么多阻碍？

>锁太复杂了，不涉及锁的实现细节。
1. 全局锁（类似全库逻辑备份的场景可以用，避免表不一致。如果不加锁，备份的时候如果用户在做操作，部分操作被备份了，部分没有）:
    1. 方法1：通过Flush tables with read lock命令，让整个库处于只读状态。其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
    2. 方法2：mysqldump使用参数–single-transaction启动一个事务，能拿到一致性读视图，可以达到全库只读。但是只有innodb可以用。
    3. 方法3：set global readonly=true也可以达到全库只读。但是readonly有别的用处（比如主从备份）。而且readonly风险更高（连接断开时，FTWRL会自动释放锁，readonly永存）。
2. 表级锁（分为两种，表锁，和，元数据锁（meta data lock，MDL））:
    1. 表锁：
        1. 语法是lock tables ... read/write。可以用unlock tables主动释放，也可以连接断开的时候自动释放。
        2. 表锁也限制自身。比如，在A线程中执行lock tables t1 read, t2 write;。那么，其他线程写t1，读t2都会被阻塞。同时，在unlock之前，A线程也只能读t1，写t2（甚至写t1都不行）。
            >其实也很好理解，如果能写t1，那么不就等于悄悄升级读锁为写锁？其他线程的读t1岂不是出错了？
        3. innodb一般用行锁。
    2. 元数据锁（应该是指表结构层面）：
        1. MDL是自动的。为了保证读写的正确性（比如线程A在遍历，线程B删了一列，那不是出错了）。
        2. 给表加字段的时候，如果改动时间久，MDL会造成后面的查询的阻塞，要慎重（设置超时，或者其他别的途径）。

## 7，行锁功过：怎么减少行锁对性能的影响？

1. 两阶段锁
    1. 在innodb事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到**事务结束时才释放**。这个就是两阶段锁协议。
    2. 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
        ```text
       假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：
       1 从顾客A账户余额中扣除电影票价；
       2 给影院B的账户余额增加这张电影票价；
       3 记录一条交易日志。
       
       首先，一个人很难在自己买票的时候做其他操作，所以1比较难冲突。
       如果有另一个顾客C也要买票，那么影院B的帐户又会变动，所以第二句更容易冲突。
       所以应该设计成132或者312这种顺序。这就最大程度地减少了事务之间的锁等待，提升了并发度。
        ```
2. 死锁和死锁检测
    1. 不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。
    2. 解决死锁有两种策略：
        1. 超时处理。
            1. 超时时间太大，造成长时间等待，在线服务难以接受。
            2. 超时时间太小，普通（非死锁）等待容易被误伤。
        2. 发起死锁检测（innodb_deadlock_detect），发现死锁，并主动回滚一个死锁事务。
            1. 消耗cpu资源。
            2. 关掉不必要的死锁检测（有风险，可能会出现大量超时）。
            3. 控制并发度。
                1. 需要专业人才。
                2. 可以考虑通过将一行改成逻辑上的多行来减少锁冲突。
                
## 8，事务到底是隔离的还是不隔离的？

1. begin/start transaction并不是事务马上执行，它之后的第一个操作innodb表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot。
2. 没有显式使用begin/commit的update语句本身就是一个事务，语句完成的时候自动提交。
3. 一致性读视图（consistent read view），用于支持RC（Read Committed）和RR（Repeatable Read）隔离级别的实现。
    1. 每个事务有一个唯一的transaction id，按申请顺序递增。
    2. 每行数据都有多个版本。事务更新时生成新数据版本，把transaction id赋值给这个版本，记为row trx_id。
        > * 旧版本保留，新版本可追溯旧版本
        > * 这些数据版本，是根据对应的undo log计算出来的。
    3. 事务创建的瞬间，创建**一致性读视图**（构造一个数组，存储了当前正在"活跃（启动但未提交）"的所有事务的ID）。
        >所有ID从小到大排列，最后一个是系统里已经创建过的的事务的ID的最大值+1（这个事务自己的ID）。
        1. 如果一个数据版本的row trx_id比数组中最小ID的还小，这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的。
        2. 如果row trx_id比数组中最大ID的还大，这个版本是由将来启动的事务生成的，是肯定不可见。
        3. 如果row trx_id介于两者之间，且在数组中，表示这个版本是由还没提交的事务生成的，不可见。
        4. 如果row trx_id介于两者之间，且不在数组中，表示这个版本是已经提交了的事务生成的，可见。
            >情况4和情况1的区别是
            >* 1当中的事务，启动时间比当前存活的事务都早，且已经提交。
            >* 4当中的事务，启动时间介于当前存活的事务之间，但是也已经提交，而且提交时间早于当前事务。
    4. 事务查询逻辑：
        1. 自己的更新，总是可见。
        2. 版本未提交，不可见。
        3. 版本已经提交，但是在视图创建之后提交，不可见。
        4. 版本已经提交，在视图创建之前提交，可见。
    5. 事务更新逻辑：
        1. 更新数据都是先读后写的，而这个读，只能读当前的值，称为"当前读"（current read）。
        >select语句如果加锁，也是当前读。select语句加上lock in share mode（读锁，共享锁）或for update（写锁，排他锁），就变成当前读。
    6. 读提交：
        1. 逻辑和可重复读基本类似，区别是，在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。
```text
举几个例子，

* 例子1，可重复读情况下

|transaction A(ID100)           |transaction B(ID101)           |transaction C(ID102)           |
|start transaction              |                               |                               |
|                               |start transaction              |                               |
|                               |                               |update t set k=k+1 where id=1; |
|                               |update t set k=k+1 where id=1; |                               |
|                               |select k from t where id=1;    |                               |
|select k from t where id=1;    |                               |                               |
|commit;                        |                               |                               |
|                               |commit;                        |                               |
例子1中，
事务A查询的时候，事务B还没提交，事务B影响的数据的row trx_id是101。
从3-iii-b角度分析，101比数组中最大的ID还大，所以不可见。
从3-iv-b角度分析，事务B还没提交，所以不可见。
此时事务C已经提交了，但是事务C提交的数据的row trx_id是102。
从3-iii-b角度分析，102比数组中最大的ID还大，所以不可见。
从3-iv-c角度分析，C已经提交，但是在视图创建之后提交，所以也是不可见。

事务B update之前，C已经update，并且commit了，所以B要使用当前读。
所以事务B的update语句获取到的k=2，+1之后=3。
又因为这个update是自己的更新，总是可见，所以事务B select出来就是3（符合3-iii-a和3-iv-a）。

* 例子2，可重复读情况下

|transaction A(ID100)           |transaction B(ID101)           |transaction C(ID102)           |
|start transaction              |                               |                               |
|                               |start transaction              |                               |
|                               |                               |start transaction              |
|                               |                               |update t set k=k+1 where id=1; |
|                               |update t set k=k+1 where id=1; |                               |
|                               |select k from t where id=1;    |                               |
|                               |                               |commit;                        |
|select k from t where id=1;    |                               |                               |
|commit;                        |                               |                               |
|                               |commit;                        |                               |
例子2中，
事务C，没有立即提交，但是row trx_id是102的数据版本已经生成了。这时候，就要结合"两阶段锁协议"。
事务C还没提交，所以锁还没有释放。
事务B是当前读，必须读最新版本，而且必须加锁，因此就阻塞。必须等到事务C释放这个锁，才能继续它的当前读。

* 例子3，读提交情况

|transaction A(ID100)           |transaction B(ID101)           |transaction C(ID102)           |
|start transaction              |                               |                               |
|                               |start transaction              |                               |
|                               |                               |update t set k=k+1 where id=1; |
|                               |update t set k=k+1 where id=1; |                               |
|                               |select k from t where id=1;    |                               |
|select k from t where id=1;    |                               |                               |
|commit;                        |                               |                               |
|                               |commit;                        |                               |
例子3中，
事务A查询的时候，
事务B还没提交，符合3-iii-c和3-iv-b，所以不可见。
事务C已经提交，符合3-iii-a和3-iv-d，所以可见。
所以A查询返回的是k=2。


事务B查询的时候，
事务C已经提交，符合3-iii-a和3-iv-d，所以可见。
事务B自己的提交符合3-iii-a和3-iv-a，所以可见。
所以A查询返回的是k=3。
```
这三个例子，把一致性读、当前读和行锁就串起来了。

## 20，幻读是什么，幻读有什么问题？（涉及gap锁）

1. 幻读的定义：一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。
2. 幻读的问题：会造成数据不一致。
3. 幻读的解决办法：
    1. innodb引入了间隙锁（Gap Lock）。
        1. 间隙锁会与"往这个间隙中插入一个记录"这个操作冲突。
        2. 间隙锁与间隙锁之间不会冲突。
        3. 间隙锁是开区间。
        4. 间隙锁和行锁，合称next-key lock。每个next-key lock是前开后闭区间。
4. 间隙锁的问题和解决：
    1. 可能会导致同样的语句锁住更大的范围，这其实是影响了并发度。
        >文中的例子是，两个session都用间隙锁锁住了一个区间，间隙锁不冲突。但是他们随后都往这个区间插入一条数据，都被对方的间隙锁锁住了，所以就死锁了。
    2. innodb中，可重复读级别下，才有间隙锁。
        1. 把隔离级别设置为读提交，就没有间隙锁了。但是，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。
5. 课后习题
    1. 问题：间隙锁和insert语句的冲突关系（分析怎么加间隙锁）。具体太长了，看原文吧。
    2. 答案：

## 21，为什么我只改一行的语句，锁这么多？（涉及加锁规则）

>本问加锁规则，只限于5.x系列<=5.7.24，8.0系列 <=8.0.13。后面的MySQL版本可能会改。
1. 规则：
    1. 原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。
    2. 原则2：查找过程中访问到的对象才会加锁。
        >在`lock in share mode`的时候，覆盖索引这种没有回表的操作，就不会锁表，只锁索引。
        >> `for update`模式下，系统认为你要更新数据，会顺便给主键索引上满足条件的行加上行锁。
    3. 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
    4. 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
    5. 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。
2. 案例
    1. 等值查询间隙锁。
    2. 非唯一索引等值锁（命中覆盖索引）。
    3. 主键索引范围锁。
    4. 非唯一索引范围锁。
    5. 唯一索引范围锁bug。
    6. 非唯一索引上存在"等值"的例子。
    7. limit 语句加锁。
    8. next-key lock（加锁分成两个阶段）的例子。







## 引用
>[深挖计算机基础：MySQL实战45讲学习笔记](https://www.cnblogs.com/luoahong/p/11792027.html)
>这个人转载之后还截取了一些精彩留言，想看可以看一点