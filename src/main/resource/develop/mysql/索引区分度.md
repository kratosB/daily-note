### 1. 什么是索引区分度

给表中的某个字段加索引的时候，索引长度是多少，可以更好的区分每一条数据，这就叫`索引区分度`。

索引区分度通常跟索引长度放在一起讨论。

首先，索引长度和区分度是相互矛盾的。索引长度太短，那么区分度就很低，把索引长度加长，区分度就高。但是索引也是要占内存的，所以我们需要找到一个平衡点。

>Mysql索引的底层是B+Tree，B+Tree的IO次数取决于B+Tree的高度h。
>
>假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N。当数据量N一定的情况下，m越大，h越小。而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么B+Tree要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

索引长度的增加，会导致B+Tree的h变大，从而增加磁盘IO的次数，降低性能。

### 2. 怎么平衡索引区分度和长度

比如用户表有个字段username，要给他加索引，索引长度是多少合适？

举个例子，username有以下三条数据

> 张，张三，张三飞

如果索引长度取1的话，那么每一行的索引都是`张`这个字，完全没有区分度，数据库无法排血，结果这样三行的顺序完全是随机排的，因为索引都一样。

如果长度取2，那么排序的时候至少前两个是排对了的。

如果取3，区分度达到100%，排序完全正确。

但是，也不能为了区分度，一味加长索引长度。那样也会导致性能下降。

所以要做一个取舍。这个取舍不是没有一个固定的量，需要跟你自己的数据库里面的数据来判断。比较常规的公式如下。

    select count(distinct left(username,5))/count(*) from table;
    
其中username是你要建立的索引的字段，5是索引长度。结果如下图。

![图片](https://images2015.cnblogs.com/blog/713671/201702/713671-20170212160030307-888200676.jpg)

可以看到，索引长度达到4的时候，区分度已经趋向1了，所以这里索引长度设为4是最佳的。

这个地方不是说必须接近1才行，其实这个值达到0.1就已经可以接受了，总之要找一个平衡点。

>还有一些特殊的字段常规方法用起不太顺畅，比如有一个url字段，绝大部分的url都是`http://www.`开头的。  
>这种情况下索引长度取取到11都是无效的，需要更长的索引，那么有没有优雅的方式来解决呢?  
>第一种方法： 可以将数据倒序存入数据库。  
>第二种方法：对字符串进行crc32哈希处理。  
>两种方法都不错，当然要配合客户端程序完成。