
## binlog

### binlog基本信息

1. binlog用于记录数据库执行的写入操作（不包括查询），以二进制的形式保存在磁盘中。
2. binlog是mysql的逻辑日志，由Server层进行记录，使用任何存储引擎的mysql数据库都会记录binlog日志。
    > 逻辑日志：可以简单理解为记录的就是sql语句。
    > 物理日志：因为mysql数据最终是保存在数据页中的，物理日志记录的就是数据页变更。
3. binlog通过追加的方式进行写入，可以通过max_binlog_size参数设置每个binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。

### binlog使用场景

1. 主从复制：master开启binlog，然后把binlog发送到slave（可以是多个），slave执行binlog从而实现主从一致。
2. 数据恢复：通过使用mysqlbinlog工具恢复数据。（简单说就是照着日志重新执行写入语句）

### binlog刷盘时间

1. 对于InnoDB来说，只有事务提交的时候才会记录binlog。记录的binlog在内存中，刷到磁盘中的时间，取决于sync_binlog这个参数。
    1. 0：由系统自动判断何时刷盘。
    2. 1：每次commit都会把binlog刷盘。
        >很明显，这个最安全，但是效率最低，这是MySQL 5.7.7之后版本的默认值。
    3. N：每N次事务提交，才会刷盘。
        >安全性低一点，但是性能好。
    >安全vs性能，经典难题，如果有个方法又安全性能又好，那别的方法就没有存在的意义了。

### binlog日志格式

binlog日志有三种格式，分别为STATMENT、ROW和MIXED。

1. STATMENT：基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。
    1. 优点：数据量比较小，比如update student set gender where age = 10这种语句，只需要一句日志，就能更新好多好多行，节约io，提高性能。
    2. 缺点：某些情况下可能会导致数据不一致（比如带limit的delete）
2. ROW：基于行的复制(row-based replication, RBR)，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了。
    1. 优点：（根据主键）精准记录每条数据的变动。
    2. 缺点：会产生大量日志，同时（主备场景下）耗费IO资源。比如alter table的语句，statement模式下可能就一句话，这个模式下就是全表所有数据，可能有十万百万句。
3. MIXED：混合复制(mixed-based replication, MBR)，一般复制使用STATEMENT模式，对于STATEMENT模式无法复制的操作使用ROW模式。
    1. 优点：灵活，节约空件。
    2. 缺点：不能用于数据恢复。

## redo log

### 为什么需要redo log

1. 为了保证持久性，每次事务提交的时候，应该将该事务涉及修改的数据页全部刷新到磁盘中。
2. 每次提交涉及的数据在磁盘上的不连续的区域。如果每次提交都要刷盘，就需要找到对应的位置再更新，是一个随机的写动作，IO性能很差。
3. redo log记录事务对数据页做了哪些修改，写在一个文件里，是顺序写，IO效率高很多，性能好。

### redo log基本概念

1. redo log包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo log file)。
2. redo log buffer写入redo log file也包括两部分：先写入OS Buffer，然后再通过系统调用fsync()将其刷到redo log file中。
3. mysql支持三种将redo log buffer写入redo log file的时机，可以通过innodb_flush_log_at_trx_commit参数配置：
    1. 0（延迟写）：事务提交时不会立即写os buffer，而是每秒写os buffer并调用fsync()。如果系统崩溃，会损失1秒的数据。
    2. 1（实时写，实时刷）：每次提交都会写os buffer并调用fsync()，IO性能差。
    3. 2（实时写，延迟刷）：每次提交都会写os buffer，每秒调用fsync()，折衷。

### redo log记录形式

1. redo log采用了大小固定，循环写入（覆盖之前已经失效的部分）的方式。
    >导致redo log不能做数据恢复，因为之前的数据都被覆盖了。
2. redo log存在的意义主要就是降低对数据页刷盘的要求。

### redo log与binlog区别

| |redo log|binlog|
|---|---|---|
文件大小|文件大小固定|可以配置每个binlog文件大小，写满了增加一个|
实现方式|InnoDB实现的，不是所有引擎都有|server层实现，所有引擎都能用|
记录方式|循环写，写到结尾时，会回到开头循环写日志。|binlog 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上|
适用场景|崩溃恢复，节约IO|主从，数据恢复|

>关于为什么不能直接用binlog做“崩溃恢复”，网上没有非常好的解释，没理解。下面有两个说得还可以，我这边写一下，不知道对错。
>1. 数据库crash之后，某一个数据页，可能有提交了一半的结果（比方一个commit在数据页层面有3个操作，已经做了两个）。
>   1. redo log是物理日志，记录了数据页的变动，所以可以先恢复数据页，然后再重做。
>   2. binlog是逻辑日志，类似update table set name = 1 where id = 1，没法实现恢复数据页的操作。
>2. 如果把binlog做成物理日志，就可以实现“崩溃恢复”了，但是那等于又做了一个新的redo log。

## undo log

1. Undo log是逻辑日志。比如一条INSERT语句，对应一条DELETE的undo log，对于每个UPDATE语句，对应一条相反的UPDATE的undo log，这样在发生错误时，就能回滚到事务之前的数据状态。
2. Undo log的作用：
    1. 回滚数据，原子性，是通过undo log实现的。
    2. MVCC一致性视图，通过Undo log找到对应的数据版本号，是保证MVCC视图的一致性的必要条件。
3. 大事务会导致日记（Undo log）过多。

## 两阶段提交

1. redo log prepare，binlog， redo log commit。
2. 两阶段提交主要是为了redo log和binlog的数据一致性。

## changeBuffer

1. 如果用到了ChangeBuffer，更新的数据所在的数据页如果不在内存中，将不用去数据磁盘将数据页读到内存，而是将这一次操作记录在ChangeBuffer中，下次读取查询等读取数据页时用上ChangeBuffer中的记录即可。
2. ChangeBuffer和Redo log都是巧用内存，减少磁盘IO。但是
    1. Redo log主要节省的是**随机写**磁盘的IO消耗（转成顺序写）。
        >写的时候不需要随机读盘，直接顺序写文件，后台刷盘。
    2. ChangeBuffer主要节省的则是**随机读**磁盘的IO消耗。
        >变更数据的时候，不需要先从磁盘中（随机）读数据，而是直接写在changeBuffer，后台刷盘。
3. ChangeBuffer merge：
    1. 从磁盘读入数据页到内存（老版本的数据页）。
    2. 从changeBuffer里找出这个数据页的记录 (可能有多个），依次应用，得到新版数据页。
    3. 写redo log。这个redo log包含了数据的变更和changeBuffer的变更。
    >除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。
4. 适合写多读少的业务，不适合读多的业务。
    >因为每次读都会触发merge，如果一直merge，随机访问IO次数不会减少，反而增加了change buffer的维护代价。

>[几年了？作为一个码农终于把MySQL日记看懂了，决定连夜肝出一篇~](https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&mid=2247509851&idx=3&sn=5a926562ab945ddeddaeeef0f8431355&chksm=e8fd3b52df8ab244f9abeccecf650e84d921b37d3f17b9e7ff41a494964641da2d3cdc219ded&xtrack=1&scene=90&subscene=93&sessionid=1603867414&clicktime=1603867468&enterid=1603867468&ascene=56&devicetype=android-29&version=2700123b&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=Ah133iZdBwGn2AP%2BCN2JcmM%3D&pass_ticket=IZMTdWmP9SLAm1gHf1KMUhUTxBTVJXMp%2BBAZwj9w7nIcZYYjoVvCxt28DNU9x1N5&wx_header=1)
>[几年了？作为一个码农终于把MySQL日记看懂了，为此肝出此文！！！](https://blog.csdn.net/qq_41055045/article/details/108681970)
>[必须了解的 MySQL 三大日志](https://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&mid=2247494650&idx=4&sn=cb7fb9900e14880c6305b29f29bdd1c3&chksm=9beeca88ac99439e5a917ddcff4be7a1addc9d29d4af3431ccfd845d6a6a6668e0d1bde5e04f&xtrack=1&scene=90&subscene=93&sessionid=1604367787&clicktime=1604367840&enterid=1604367840&ascene=56&devicetype=android-29&version=270014ab&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=Ag%2FlTiMx8vUlUQMHUeyGY3o%3D&pass_ticket=WgRuAPnuJYEbd2%2FANoPFiHpoQsAUQl3W8mbFOA62s%2BzqIqfNSbgUeVKwFz56LPBL&wx_header=1)
>[必须了解的 MySQL 三大日志](https://juejin.cn/post/6860252224930070536)
>[详细分析MySQL事务日志(redo log和undo log)](https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_11)