
## binlog

### binlog基本信息

1. binlog用于记录数据库执行的写入操作（不包括查询），以二进制的形式保存在磁盘中。
2. binlog是mysql的逻辑日志，由Server层进行记录，使用任何存储引擎的mysql数据库都会记录binlog日志。
    > 逻辑日志：可以简单理解为记录的就是sql语句。
    > 物理日志：因为mysql数据最终是保存在数据页中的，物理日志记录的就是数据页变更。
3. binlog通过追加的方式进行写入，可以通过max_binlog_size参数设置每个binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。

### binlog使用场景

1. 主从复制：master开启binlog，然后把binlog发送到slave（可以是多个），slave执行binlog从而实现主从一致。
2. 数据恢复：通过使用mysqlbinlog工具恢复数据。（简单说就是照着日志重新执行写入语句）

### binlog刷盘时间

1. 对于InnoDB来说，只有事务提交的时候才会记录binlog。记录的binlog在内存中，刷到磁盘中的时间，取决于sync_binlog这个参数。
    1. 0：由系统自动判断何时刷盘。
    2. 1：每次commit都会把binlog刷盘。
        >很明显，这个最安全，但是效率最低，这是MySQL 5.7.7之后版本的默认值。
    3. N：每N次事务提交，才会刷盘。
        >安全性低一点，但是性能好。
    >安全vs性能，经典难题，如果有个方法又安全性能又好，那别的方法就没有存在的意义了。

### binlog日志格式

binlog日志有三种格式，分别为STATMENT、ROW和MIXED。

1. STATMENT：基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。
    1. 优点：数据量比较小，比如update student set gender where age = 10这种语句，只需要一句日志，就能更新好多好多行，节约io，提高性能。
    2. 缺点：某些情况下可能会导致数据不一致（比如带limit的delete）
2. ROW：基于行的复制(row-based replication, RBR)，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了。
    1. 优点：（根据主键）精准记录每条数据的变动。
    2. 缺点：会产生大量日志，同时（主备场景下）耗费IO资源。比如alter table的语句，statement模式下可能就一句话，这个模式下就是全表所有数据，可能有十万百万句。
3. MIXED：混合复制(mixed-based replication, MBR)，一般复制使用STATEMENT模式，对于STATEMENT模式无法复制的操作使用ROW模式。
    1. 优点：灵活，节约空件。
    2. 缺点：不能用于数据恢复。

## redo log

### 为什么需要redo log

1. 为了保证持久性，每次事务提交的时候，应该将该事务涉及修改的数据页全部刷新到磁盘中。
2. 每次提交涉及的数据在磁盘上的不连续的区域。如果每次提交都要刷盘，就需要找到对应的位置再更新，是一个随机的写动作，IO性能很差。
3. redo log记录事务对数据页做了哪些修改，写在一个文件里，是顺序写，IO效率高很多，性能好。

### redo log基本概念

1. redo log包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo log file)。
2. redo log buffer写入redo log file也包括两部分：先写入OS Buffer，然后再通过系统调用fsync()将其刷到redo log file中。
3. mysql支持三种将redo log buffer写入redo log file的时机，可以通过innodb_flush_log_at_trx_commit参数配置：
    1. 0（延迟写）：事务提交时不会立即写os buffer，而是每秒写os buffer并调用fsync()。如果系统崩溃，会损失1秒的数据。
    2. 1（实时写，实时刷）：每次提交都会写os buffer并调用fsync()，IO性能差。
    3. 2（实时写，延迟刷）：每次提交都会写os buffer，每秒调用fsync()，折衷。

### redo log记录形式

1. redo log采用了大小固定，循环写入（覆盖之前已经失效的部分）的方式。
    >导致redo log不能做数据恢复，因为之前的数据都被覆盖了。
2. redo log存在的意义主要就是降低对数据页刷盘的要求。

### redo log与binlog区别

| |redo log|binlog|
|---|---|---|
文件大小|文件大小固定|可以配置每个binlog文件大小，写满了增加一个|
实现方式|InnoDB实现的，不是所有引擎都有|server层实现，所有引擎都能用|
记录方式|循环写，写到结尾时，会回到开头循环写日志。|binlog 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上|
适用场景|崩溃恢复，节约IO|主从，数据恢复|

>关于为什么不能直接用binlog做“崩溃恢复”，网上没有非常好的解释，没理解。下面有两个说得还可以，我这边写一下，不知道对错。
>1. 数据库crash之后，某一个数据页，可能有提交了一半的结果（比方一个commit在数据页层面有3个操作，已经做了两个）。
>   1. redo log是物理日志，记录了数据页的变动，所以可以先恢复数据页，然后再重做。
>   2. binlog是逻辑日志，类似update table set name = 1 where id = 1，没法实现恢复数据页的操作。
>2. 如果把binlog做成物理日志，就可以实现“崩溃恢复”了，但是那等于又做了一个新的redo log。

## undo log

1. 原子性，是通过undo log实现的。
2. undo log主要记录了数据的逻辑变化，比如一条INSERT语句，对应一条DELETE的undo log，对于每个UPDATE语句，对应一条相反的UPDATE的undo log，这样在发生错误时，就能回滚到事务之前的数据状态。
3. undo log也是MVCC(多版本并发控制)实现的关键，多版本都是通过undo log计算出来的。

>[几年了？作为一个码农终于把MySQL日记看懂了，决定连夜肝出一篇~](https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&mid=2247509851&idx=3&sn=5a926562ab945ddeddaeeef0f8431355&chksm=e8fd3b52df8ab244f9abeccecf650e84d921b37d3f17b9e7ff41a494964641da2d3cdc219ded&xtrack=1&scene=90&subscene=93&sessionid=1603867414&clicktime=1603867468&enterid=1603867468&ascene=56&devicetype=android-29&version=2700123b&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=Ah133iZdBwGn2AP%2BCN2JcmM%3D&pass_ticket=IZMTdWmP9SLAm1gHf1KMUhUTxBTVJXMp%2BBAZwj9w7nIcZYYjoVvCxt28DNU9x1N5&wx_header=1)
>[必须了解的 MySQL 三大日志](https://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&mid=2247494650&idx=4&sn=cb7fb9900e14880c6305b29f29bdd1c3&chksm=9beeca88ac99439e5a917ddcff4be7a1addc9d29d4af3431ccfd845d6a6a6668e0d1bde5e04f&xtrack=1&scene=90&subscene=93&sessionid=1604367787&clicktime=1604367840&enterid=1604367840&ascene=56&devicetype=android-29&version=270014ab&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=Ag%2FlTiMx8vUlUQMHUeyGY3o%3D&pass_ticket=WgRuAPnuJYEbd2%2FANoPFiHpoQsAUQl3W8mbFOA62s%2BzqIqfNSbgUeVKwFz56LPBL&wx_header=1)
>[必须了解的 MySQL 三大日志](https://juejin.cn/post/6860252224930070536)
>[详细分析MySQL事务日志(redo log和undo log)](https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_11)