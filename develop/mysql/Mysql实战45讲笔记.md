## 3，事务隔离：为什么你改了我还看不见？


### 引用
>* [关于MySQL的可重复读的理解](https://blog.csdn.net/qq_32573109/article/details/98610368)
>* [隔离级别+不可重复读+幻读](https://blog.csdn.net/zzp448561636/article/details/80917085)
>
>可重复读没看懂，搜了点资料，第一个帖子看了，有点似懂非懂。第二个帖子还没看，就扫了一眼。奇怪的是，这俩帖子的参考资料，就是我看的45讲，我也是醉了，我怎么没看出来这么多信息。
>
>* [MySQL使用可重复读作为默认隔离级别的原因](https://www.cnblogs.com/vinchen/archive/2012/11/19/2777919.html)
>
>有空可以看看上面这个帖子，可能有用。

## 4，深入浅出索引（上）

1. Hash查询快，但是区间查询慢。
2. 有序数组查询快，新增慢。
3. 二叉树层数多，读磁盘多，速度慢，所以用**多叉树**。
4. 自增主键的好处:
    1. 有序，插入快。
    2. 二级索引节省空间。（因为二级索引等于是key-value结构，key是索引，value是主键，自增主键占用空间小）
5. 主键唯一，没有其他索引，没有其他查询需求，可以用业务字段做索引。

## 5，深入浅出索引（下）

1. 使用覆盖索引，避免回表，尤其，**范围查询要回表很多次**。
2. 最左前缀原则。
3. 索引下推:
   1. 比如select * from tuser where name like '张%' and age=10 and ismale=1;
   2. 先通过(name,age)的索引，找到'张%'匹配的地方。
   3. 然后Mysql5.6之前的版本，数据库会直接开始回表比对字段。
   4. 5.6之后的版本引入了索引下推优化。可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
   
## 6，全局锁和表锁 ：给表加个字段怎么有这么多阻碍？
>锁太复杂了，不涉及锁的实现细节。
1. 全局锁:
    1. 通过Flush tables with read lock (FTWRL)命令，让整个库处于只读状态。其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
    2. 类似全库逻辑备份的场景可以用，避免表不一致（备份的时候如果用户在做操作，部分操作被备份了，部分没有）。
    3. mysqldump使用参数–single-transaction启动一个事务，能拿到一致性视图，可以达到全库只读。但是只有innodb可以用。
    4. set global readonly=true也可以达到全库只读。但是readonly有别的用处（比如主从备份）。而且readonly风险更高（连接断开时，FTWRL会自动释放锁，readonly永存）。
2. 表级锁:
    1. 分为两种，表锁，和，元数据锁（meta data lock，MDL）。
    2. 表锁：
        1. 语法是lock tables ... read/write。可以用unlock tables主动释放，也可以连接断开的时候自动释放。
        2. 表锁也限制自身。比如，在A线程中执行lock tables t1 read, t2 write;。那么，其他线程写t1，读t2都会被阻塞。同时，在unlock之前，A线程也只能读t1，写t2（甚至写t1都不行）。
            >其实也很好理解，如果能写t1，那么不就等于悄悄升级读锁为写锁？其他线程的读t1岂不是出错了？
        3. innodb一般用行锁。
    3. 元数据锁（应该是指表结构层面）：
        1. MDL是自动的。为了保证读写的正确性（比如线程A在遍历，线程B删了一列，那不是出错了）。
        2. 给表加字段的时候，如果改动时间久，MDL会造成后面的查询的阻塞，要慎重（设置超时，或者其他别的途径）。