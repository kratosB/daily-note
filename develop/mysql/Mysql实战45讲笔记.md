## 3，事务隔离：为什么你改了我还看不见？


### 引用
>* [关于MySQL的可重复读的理解](https://blog.csdn.net/qq_32573109/article/details/98610368)
>* [隔离级别+不可重复读+幻读](https://blog.csdn.net/zzp448561636/article/details/80917085)
>
>可重复读没看懂，搜了点资料，第一个帖子看了，有点似懂非懂。第二个帖子还没看，就扫了一眼。奇怪的是，这俩帖子的参考资料，就是我看的45讲，我也是醉了，我怎么没看出来这么多信息。
>
>* [MySQL使用可重复读作为默认隔离级别的原因](https://www.cnblogs.com/vinchen/archive/2012/11/19/2777919.html)
>
>有空可以看看上面这个帖子，可能有用。

## 4，深入浅出索引（上）

1. Hash查询快，但是区间查询慢。
2. 有序数组查询快，新增慢。
3. 二叉树层数多，读磁盘多，速度慢，所以用**多叉树**。
4. 自增主键的好处:
    1. 有序，插入快。
    2. 二级索引节省空间。（因为二级索引等于是key-value结构，key是索引，value是主键，自增主键占用空间小）
5. 主键唯一，没有其他索引，没有其他查询需求，可以用业务字段做索引。

## 5，深入浅出索引（下）

1. 使用覆盖索引，避免回表，尤其，**范围查询要回表很多次**。
2. 最左前缀原则。
3. 索引下推:
   1. 比如select * from tuser where name like '张%' and age=10 and ismale=1;
   2. 先通过(name,age)的索引，找到'张%'匹配的地方。
   3. 然后Mysql5.6之前的版本，数据库会直接开始回表比对字段。
   4. 5.6之后的版本引入了索引下推优化。可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
   
## 6，全局锁和表锁 ：给表加个字段怎么有这么多阻碍？

>锁太复杂了，不涉及锁的实现细节。
1. 全局锁（类似全库逻辑备份的场景可以用，避免表不一致。如果不加锁，备份的时候如果用户在做操作，部分操作被备份了，部分没有）:
    1. 方法1：通过Flush tables with read lock (FTWRL)命令，让整个库处于只读状态。其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
    2. 方法2：mysqldump使用参数–single-transaction启动一个事务，能拿到一致性读视图，可以达到全库只读。但是只有innodb可以用。
    3. 方法3：set global readonly=true也可以达到全库只读。但是readonly有别的用处（比如主从备份）。而且readonly风险更高（连接断开时，FTWRL会自动释放锁，readonly永存）。
2. 表级锁（分为两种，表锁，和，元数据锁（meta data lock，MDL））:
    1. 表锁：
        1. 语法是lock tables ... read/write。可以用unlock tables主动释放，也可以连接断开的时候自动释放。
        2. 表锁也限制自身。比如，在A线程中执行lock tables t1 read, t2 write;。那么，其他线程写t1，读t2都会被阻塞。同时，在unlock之前，A线程也只能读t1，写t2（甚至写t1都不行）。
            >其实也很好理解，如果能写t1，那么不就等于悄悄升级读锁为写锁？其他线程的读t1岂不是出错了？
        3. innodb一般用行锁。
    2. 元数据锁（应该是指表结构层面）：
        1. MDL是自动的。为了保证读写的正确性（比如线程A在遍历，线程B删了一列，那不是出错了）。
        2. 给表加字段的时候，如果改动时间久，MDL会造成后面的查询的阻塞，要慎重（设置超时，或者其他别的途径）。

## 7，行锁功过：怎么减少行锁对性能的影响？

1. 两阶段锁
    1. 在innoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到**事务结束时才释放**。这个就是两阶段锁协议。
    2. 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
        ```text
       假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：
       1 从顾客A账户余额中扣除电影票价；
       2 给影院B的账户余额增加这张电影票价；
       3 记录一条交易日志。
       
       首先，一个人很难在自己买票的时候做其他操作，所以1比较难冲突。
       如果有另一个顾客C也要买票，那么影院B的帐户又会变动，所以第二句更容易冲突。
       所以应该设计成132或者312这种顺序。这就最大程度地减少了事务之间的锁等待，提升了并发度。
        ```
2. 死锁和死锁检测
    1. 不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。
    2. 解决死锁有两种策略：
        1. 超时处理。
            1. 超时时间太大，造成长时间等待，在线服务难以接受。
            2. 超时时间太小，普通（非死锁）等待容易被误伤。
        2. 发起死锁检测（innodb_deadlock_detect），发现死锁，并主动回滚一个死锁事务。
            1. 消耗cpu资源。
            2. 关掉不必要的死锁检测（有风险，可能会出现大量超时）。
            3. 控制并发度。
                1. 需要专业人才。
                2. 可以考虑通过将一行改成逻辑上的多行来减少锁冲突。
                
## 8，事务到底是隔离的还是不隔离的？

1. begin/start transaction并不是事务马上执行，它之后的第一个操作InnoDB表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot。
2. 没有显式使用begin/commit的update语句本身就是一个事务，语句完成的时候自动提交。
3. 一致性读视图（consistent read view），用于支持RC（Read Committed）和RR（Repeatable Read）隔离级别的实现。
    1. 每个事务有一个唯一的transaction id，按申请顺序递增。
    2. 每行数据都有多个版本。事务更新时生成新数据版本，把transaction id赋值给这个版本，记为row trx_id。
        > * 旧版本保留，新版本可追溯旧版本
        > * 这些数据版本，是根据对应的undo log计算出来的。
    3. 事务创建的瞬间，创建**一致性读视图**（构造一个数组，存储了当前正在“活跃（启动但未提交）”的所有事务的ID）。
        >所有ID从小到大排列，最后一个是系统里已经创建过的的事务的ID的最大值+1（这个事务自己的ID）。
        1. 如果一个数据版本的row trx_id比数组中最小ID的还小，这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的。
        2. 如果row trx_id比数组中最大ID的还大，这个版本是由将来启动的事务生成的，是肯定不可见。
        3. 如果row trx_id介于两者之间，且在数组中，表示这个版本是由还没提交的事务生成的，不可见。
        4. 如果row trx_id介于两者之间，且不在数组中，表示这个版本是已经提交了的事务生成的，可见。
            >情况4和情况1的区别是
            >* 1当中的事务，启动时间比当前存活的事务都早，且已经提交。
            >* 4当中的事务，启动时间介于当前存活的事务之间，但是也已经提交，而且提交时间早于当前事务。
    4. 事务查询逻辑：
        1. 自己的更新，总是可见。
        2. 版本未提交，不可见。
        3. 版本已经提交，但是在视图创建之后提交，不可见。
        4. 版本已经提交，在视图创建之前提交，可见。
    5. 事务更新逻辑：
        1. 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。
        >select语句如果加锁，也是当前读。select语句加上lock in share mode（读锁，共享锁）或for update（写锁，排他锁），就变成当前读。
    6. 读提交：
        1. 逻辑和可重复读基本类似，区别是，在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。
```text
举几个例子，

例子1，可重复读情况下

|transaction A(ID100)           |transaction B(ID101)           |transaction C(ID102)           |
|start transaction              |                               |                               |
|                               |start transaction              |                               |
|                               |                               |update t set k=k+1 where id=1; |
|                               |update t set k=k+1 where id=1; |                               |
|                               |select k from t where id=1;    |                               |
|select k from t where id=1;    |                               |                               |
|commit;                        |                               |                               |
|                               |commit;                        |                               |
例子1中，
事务A查询的时候，事务B还没提交，事务B影响的数据的row trx_id是101。
从3-iii-b角度分析，101比数组中最大的ID还大，所以不可见。
从3-iv-b角度分析，事务B还没提交，所以不可见。
此时事务C已经提交了，但是事务C提交的数据的row trx_id是102。
从3-iii-b角度分析，102比数组中最大的ID还大，所以不可见。
从3-iv-c角度分析，C已经提交，但是在视图创建之后提交，所以也是不可见。

事务B update之前，C已经update，并且commit了，所以B要使用当前读。
所以事务B的update语句获取到的k=2，+1之后=3。
又因为这个update是自己的更新，总是可见，所以事务B select出来就是3（附合3-iii-a和3-iv-a）。

例子2，可重复读情况下

|transaction A(ID100)           |transaction B(ID101)           |transaction C(ID102)           |
|start transaction              |                               |                               |
|                               |start transaction              |                               |
|                               |                               |start transaction              |
|                               |                               |update t set k=k+1 where id=1; |
|                               |update t set k=k+1 where id=1; |                               |
|                               |select k from t where id=1;    |                               |
|                               |                               |commit;                        |
|select k from t where id=1;    |                               |                               |
|commit;                        |                               |                               |
|                               |commit;                        |                               |
例子2中，
事务C，没有立即提交，但是row trx_id是102的数据版本已经生成了。这时候，就要结合“两阶段锁协议”。
事务C还没提交，所以锁还没有释放。
事务B是当前读，必须读最新版本，而且必须加锁，因此就阻塞。必须等到事务C释放这个锁，才能继续它的当前读。

例子3，读提交情况
|transaction A(ID100)           |transaction B(ID101)           |transaction C(ID102)           |
|start transaction              |                               |                               |
|                               |start transaction              |                               |
|                               |                               |update t set k=k+1 where id=1; |
|                               |update t set k=k+1 where id=1; |                               |
|                               |select k from t where id=1;    |                               |
|select k from t where id=1;    |                               |                               |
|commit;                        |                               |                               |
|                               |commit;                        |                               |
例子3中，
事务A查询的时候，
事务B还没提交，附合3-iii-c和3-iv-b，所以不可见。
事务C已经提交，附合3-iii-a和3-iv-d，所以可见。
所以A查询返回的是k=2。


事务B查询的时候，
事务C已经提交，附合3-iii-a和3-iv-d，所以可见。
事务B自己的提交附合3-iii-a和3-iv-a，所以可见。
所以A查询返回的是k=3。
```
这三个例子，把一致性读、当前读和行锁就串起来了。

## 9，普通索引和唯一索引，应该怎么选择？