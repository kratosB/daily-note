## 第三章 垃圾收集器与内存分配策略

目前的内存分配和回收技术已经很成熟，但是当内存溢出，内存泄漏，或者垃圾收集成为系统达到**更高并发量**的瓶颈时，还需要关注内存分配和垃圾回收。

程序计数器，虚拟机栈，本地方法栈，这几个区域的内存的分配和回收，都具备确定性，所以不用过多考虑内存回收问题。
1. **分配多少内存在类的结构中已经确定了**。
2. **方法结束的时候内存跟着就回收了**。

Java堆和方法区不一样。
1. **一个接口的多个实现类需要的内存可能不一样**。
2. **一个方法的多个分支需要的内存也不一样**。
3. **一个对象实例可能被多个方法引用，所以回收的时间也不是确定的**。

### 3.1 对象已死？

垃圾回收的基础，是确定对象实例是否还活着（不再被任何人引用，就说明已经死去）

#### 3.1.1 引用计数算法

在对象中添加一个**引用计数器**，每当有一个地方引用它时，计数器的值就+1，当引用失效时，计数器的值就-1。当**计数器为0**时，这个对象就是**不再被使用的对象**。

这种方法最大的问题是，它很难解决**对象之间的互相循环引用**的问题。下面的代码就是一个循环引用的例子。

    public class ReferenceCountingGC {
    
        public Object instance = null;
    
        private static final int _1MB = 1024 * 1024;
    
        /**
         * 这个成员属性的意义时占用一点内存，便于在GC日志中清晰的看出内存是否被回收
         */
        private byte[] bigSize = new byte[2 * _1MB];
    
        public static void main(String[] args) {
            ReferenceCountingGC objA = new ReferenceCountingGC();
            ReferenceCountingGC objB = new ReferenceCountingGC();
            objA.instance = objB;
            objB.instance = objA;
    
            objA = null;
            objB = null;
    
            // 假设在这里发生GC，那么objA和objB能否被回收
            System.gc();
        }
    
    }

上面的代码中，objA和objB**互相引用对方**，导致它们的**引用计数器都不是0**，但实际上这两个对象已经没用了。如果GC收集器判断对象实例是否死亡的依据是引用计数器的话，`System.gc()`的时候，内存就不会被回收。但是实际上内存却被回收了，说明**Java虚拟机不使用计数器算法来判断对象实例是否存活**。

#### 3.1.2 根搜索算法（GC Roots Tracing）

![](https://images.cnblogs.com/cnblogs_com/andy-zhou/806435/o_Jvm_Tuning005.png)

通过一些**“GC Roots”对象作为起始点**，向下搜索，搜索所走过的路径（称为引用链），当一个对象**到GC Roots没有任何引用链相连**（简单说就是从GC Roots到这个对象不可达）时，则证明这个**对象不可用**。

Java中可作为GC Roots的对象有一下几种：
1. **虚拟机栈中**（栈帧中的本地变量表）的引用的对象。
2. **方法区中的类静态属性**引用的对象。
3. **方法区中的常量**引用的对象。
4. **本地方法中**JNI（native方法）的引用的对象。

![](https://img-blog.csdn.net/20171129142211991?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY4NjY4MDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

如图所示，Object5，6，7虽然不像关联，但是它们是GC Roots不可达的，所以是可回收的对象

#### 3.1.3 再谈引用

1. 不论引用计数算法，还是根搜索算法，判定标准都与**引用**有关。
2. 最早的时候，Java堆引用的定义很传统：如果reference类型的数据中存储的数值是**代表另一块内存的起始地址**，那么就称**这块内存代表一个引用**。
3. 设计者认为，在内存足够的时候，可以存在一些缓存，所以jdk1.2之后的版本，引用类型有四种：强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）。
    1. **强引用**：Java中普遍存在的类似`Object obj = new Object()`这类引用就是强引用。强引用**只要还存在，垃圾回收器永远不会回收**被引用对象。
    2. **软引用**：在jdk1.2之后，提供了**SoftReference**类来实现软引用。软引用描述一些**还有用，但不是必须**的对象。在系统**内存要溢出之前**，才会回收软引用。
    3. **弱引用**：在jdk1.2之后，提供了**WeakReference**类来实现弱引用。弱引用比软引用更弱，弱引用关联的对象，**只能生存到下次垃圾回收之前**，只要发生垃圾回收，不论内存够不够，弱引用的关联的对象都会被回收掉。
    4. **虚引用**：在jdk1.2之后，提供了**PhantomReference**类来实现虚引用。需引用**完全不会对其生存时间构成影响**，也**无法通过虚引用来取得一个对象实例**。设置虚引用的目的是，希望能在这个**对象被收集时收到一个系统通知**。

#### 3.1.4 生存还是死亡？

1. 根搜索算法中不可达的对象，也不是立马被回收，一个对象被回收，需要**经历两次标记过程**。
    1. 如果对象被发现，没有与GC Roots相连的引用链，它会被**第一次标记**，并进行**一次筛选（筛选的条件是，这个对象是否有必要执行finalize()方法）**。
        * 如果对象**没有覆盖finalize()方法**，或者finalize()方法**已经被虚拟机调用过**，那么虚拟机认为**没必要执行finalize()方法**了（**这个对象就没机会了**）。
        * 如果虚拟机认为有必要执行finalize()方法，这个对象会被放到一个叫**F-Queue的队列**中，稍后由一个**低优先级的Finalizer线程**执行。
            > 这个方法会被出发，但并不一定会结束，因为如果这个对象的finalize()方法**特别慢或者死循环**，后面的其他对象都得等着，系统可能会崩溃。
    2. 如果对象在finalize()方法中把自己的值赋给了其他猴哥变量，那么它就不会被第二次标记，否则就会被**第二次标记**（离死不远了）。
    
下面是一段示例代码：
    
    public class FinalizeEscapeGC {
    
        private static FinalizeEscapeGC SAVE_HOOK = null;
    
        private void isAlive() {
            System.out.println("yes, I am still alive.");
        }
    
        protected void finalize() throws Throwable {
            super.finalize();
            System.out.println("finalize method executed");
            FinalizeEscapeGC.SAVE_HOOK = this;
        }
    
        public static void main(String[] args) throws Throwable {
            SAVE_HOOK = new FinalizeEscapeGC();
    
            // 对象第一次成功拯救自己
            SAVE_HOOK = null;
            System.gc();
            // 因为Finalizer方法的优先级比较低，所以暂停0.5秒，登登它
            Thread.sleep(500);
            if (SAVE_HOOK != null) {
                SAVE_HOOK.isAlive();
            } else {
                System.out.println("no, I am dead.");
            }
    
            // 下面这段代码完全相同，但是这次自救却失败了，因为finalize()方法只会被调用一次
            SAVE_HOOK = null;
            System.gc();
            // 因为Finalizer方法的优先级比较低，所以暂停0.5秒，登登它
            Thread.sleep(500);
            if (SAVE_HOOK != null) {
                SAVE_HOOK.isAlive();
            } else {
                System.out.println("no, I am dead.");
            }
        }
    }

运行结果：

    finalize method executed
    yes, I am still alive.
    no, I am dead.
    
1. 示例代码中可以看到，finalize()方法被触发了，对象在被回收前被拯救了。
2. 上面相同的代码重复了两遍，第一遍成功了，第二次失败。因为finalize()方法**只会被自动调用一次**，上面说到过“如果finalize()方法已经被虚拟机调用过，虚拟机认为没必要执行finalize()方法了”，只有没被调用过的，才会被调用。
3. **但是这个功能，不是很推荐使用，代价比较高，不确定性太大。**

#### 3.1.5 回收方法区

1. 虚拟机规范说过“**不要虚拟机在方法区实现垃圾回收**”。
2. 堆中垃圾回收**性价比高**（年轻代可以回收70% - 95%的空间），方法区（1.8之前是永久带）**回收效率很低**。
3. 永久带的垃圾收集主要分两部分：**废弃常量**和**无用的类**。
    1. 回收常量与堆种回收对象**非常相似**。假如一个字符串“abc”进入了常量池，但是当前系统没有任何一个String对象也是“abc”，说明**没有其他地方引用**了这个字面量。如果这时候发生内存回收，必要时常量“abc”会被回收掉。常量池中的**其他类（接口）**，**方法**，**字段**的符号引用也类似
    2. 判断**废弃常量**很简单，判断无用的类比较复杂，需要满足如下3个条件。满足条件的无用类**可以被回收，但不是必须**。
        1. 该类的**所有实例**都已经被回收，Java堆中不存在该类的任何实例。
        2. 加载该类的ClassLoader已经被回收。
        3. 该类对应的java.lang.Class对象**没有在任何地方被引用**，无法在任何地方**通过反射**访问该类的方法。

### 3.2 垃圾收集算法

由于垃圾回收算法的实现涉及大量细节，而且各个平台虚拟机操作内存的方式都不一样，这边不讨论实现，只介绍思想。

#### 3.2.1 标记-清除算法（Mark-Sweep）

![标记清除](https://images.cnblogs.com/cnblogs_com/andy-zhou/806435/o_Jvm_Tuning002.png "标记清除")

1. 算法分为**标记**和**清除**两个阶段。
    1. **标记出所有**需要回收的对象。
    2. 标记完成之后，**统一回收**所有被标记对象。
2. 主要有两个**缺点**：
    1. 效率问题：标记和清除过程，**效率都不高**。
    2. 空间问题：标记清除之后，会产生大量不连续的**内存碎片**，碎片过多有可能会造成**大对象无法分配**，不得不**提前**回收垃圾。

#### 3.2.2 复制算法（Copying）

![复制算法](https://images.cnblogs.com/cnblogs_com/andy-zhou/806435/o_Jvm_Tuning003.png "复制算法")

1. 算法将内存分成两块，每次**只用其中一块**。
2. 当这块内存满了，就把**还存活**的对象复制到另一块上面，然后把已经使用过的内存空间**一次性清理掉**。
3. **优点**：实现简单，运行高效，**不考虑碎片**问题。
4. **缺点**：
    1. 只有一半的内存可以使用。
    2. 在对象**存活率比较高**的时候，需要执行**太多的复制**操作，效率会降低。
5. 大多数虚拟机用这种算法来回收**年轻代**。

#### 3.2.3 标记-整理算法（Mark-Compact）

![标记整理](https://images.cnblogs.com/cnblogs_com/andy-zhou/806435/o_Jvm_Tuning004.png "标记整理")

1. 算法分为**标记**和**整理**两个阶段。
    1. 标记阶段跟**标记清除**算法一样。
    2. 不直接清理可回收对象，而是让所有存活对象**向一端移动**，然后**清理边界以外的内存**。
2. **优点**：
    1. 避免了**标记清除**算法的**碎片**问题
    2. 避免了**复制**算法的**空间**问题

#### 3.2.4 分代收集算法

![分代回收示意图](https://images.cnblogs.com/cnblogs_com/andy-zhou/806435/o_Jvm_Tuning006.png "分代回收示意图")

1. 不同的对象的**生命周期**是不一样的。
    > 1. Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此**生命周期比较长**。
    > 2. 还有一些对象，主要是程序运行过程中生成的临时变量，这些对象**生命周期会比较短**，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。
2. 所以不同生命周期的对象可以采取**不同的收集方式**，以便**提高回收效率**。
    > 1. 如果不进行对象存活时间区分，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长。
    > 2. 如果不进行对象存活时间区分，每次回收都需要遍历所有存活对象。对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。
3. 分代收集算法根据对象的存活周期的不同将内存**划分为几块**，把不同生命周期的对象放在不同代（**年轻代**和**年老待**）上，不同代上采用**最适合**它的垃圾回收方式进行回收。
4. 所有新生成的对象首先都是放在年轻代的（除非是**超大对象**，年轻代**放不下**）。
5. 在年轻代中经历了**N次垃圾回收后仍然存活**的对象，才会被放到老年代中。

##### 年轻代

1. 年轻代使用**复制算法**。
    1. 因为每次垃圾回收都会有**大批对象死**去（IBM的研究表明，**98%的对象**都是很快消亡的）。所以每次垃圾回收，只需复制**少量存活对象**就可以完成收集。
        1. 复制过程中，只**需要比较少的额外空间**来存放内存回收之后还存在的对象。
        2. **复制的速度比较快**。
2. 年轻代分**三个区**。一个**Eden区**，两个**Survivor区**(一般而言，根据程序需要，Survivor区是**可以**配置为多个的)。
    1. 因为大部分对象在第一次回收的时候立马会被回收，所以**不需要1：1的划分**内存空间。
    2. 虚拟机将年轻代分为**一块较大的Eden**和**两块较小的Survivor**。
    3. Eden区：Survivor1区：Survivor2区 = 8：1：1。
    4. Eden区是**连续的**内存空间，因此在其上分配内存**极快**。
3. 具体操作如下：
    1. 绝大多数**刚创建**的对象会被分配在**Eden区**。
    2. **Eden区满**的时候，执行Minor GC，清理掉消亡对象，将**剩余的（存活的）对象**复制到Survivor1区。
    3. **下次Eden区满了**，再执行Minor GC，清理掉**Eden区和Survivor1区**中的消亡对象，将**剩余的（Eden区和Survivor1区中存活的）对象**复制到Survivor2区。
    4. 重复上面的2和3的操作。
    5. 发生以下情况，对象会**晋级到老年代**。
        1. **存活的**对象在两个**Survivor区切换**了好多次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）
        2. 从Survivor1复制到Survivor2时（或者反过来），如果Survivor2已经满了，从**Survivor1复制过来**的并且**此时还存活**的对象，将被复制老年代。
        3. 对象太大，Eden区放不下，则大对象会**直接分配到老年代**。
4. 在Eden区，HotSpot虚拟机使用了两种技术来加快内存分配。
    1. bump-the-pointer（~~指针碰撞？~~）：Eden区是连续的，使用过的内存十分规整（用过的在一边，其他在另一边，**没有碎片**），在对象创建时，只需要**检查最后一个对象后面**是否有**足够的内存**，从而**大大加快**内存分配速度。
    2. TLAB（Thread-Local Allocation Buffers）：TLAB技术是对于多线程而言的，将Eden区分为若干段，**每个线程使用独立的一段**，避免相互影响。
    3. TLAB结合bump-the-pointer技术，将保证每个线程都使用Eden区的一段，并快速的分配内存。

##### 老年代

1. 老年代使用**标记清除**或**标记整理**算法。
    1. 因为老年代中的对象**存活率高**。
        1. 如果用复制算法，需要**很多额外空间**来存放内存回收后还存在的对象。
        2. 如果用复制算法，每次都要**复制许多对象**到新的内存区域，复制**速度太慢**。
2. 对象如果在年轻代**存活了足够长的时间**而**没有被清理掉**（即在几次Young GC后存活了下来），则会被复制到老年代。
3. 老年代的空间一般比年轻代大，能存放更多的对象。
4. 在老年代上发生的GC次数也比年轻代少。
5. 当老年代内存不足时，将执行Major GC，也叫 Full GC。
6. 在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC。
7. 老年代中维护一个512 byte的块—"card table"，所有**老年代对象引用新生代对象**的记录都记录在这里。Young GC时，只要查这里即可，**不用再去查全部老年代**，因此性能大大提高。

### 3.3 垃圾收集器

![垃圾收集器](https://static.oschina.net/uploads/img/201704/05150313_cppm.png "垃圾收集器")

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），这个虚拟机包含的所有收集器如图所示。

1. 图中展示了7种作用于不同分代的收集器，如果两个收集器之间**存在连线**，就说明它们**可以搭配使用**。
2. 虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。
3. 直到现在为止还**没有最好的收集器**出现，更加没有万能的收集器，所以我们选择的只是对具体应用**最合适**的收集器。

> 解释一下，并行（Parallel）和并发（Concurrent）的区别
>
> 并行（Parallel）：指多条垃圾收集线程并行工作，但此时**用户线程仍然处于等待状态**。
>
> 并发（Concurrent）：指用户线程与垃圾收集线程**同时执行**（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。

#### 3.3.1 Serial收集器

![Serial/Serial Old收集器示意图](https://static.oschina.net/uploads/img/201704/05150422_H3Hh.png "Serial/Serial Old收集器示意图")

1. Serial收集器是一个**新生代收集器**。
2. 这个收集器是一个单线程的收集器。
3. 在它进行垃圾收集时，必须**暂停其他所有的工作线程**，直到它收集结束。
4. 到现在为止，它依然是虚拟机运行在**Client模式**下的默认新生代收集器。
5. 简单而高效（与其他收集器的单线程比）。

#### 3.3.2 ParNew收集器

![ParNew/Serial Old收集器](https://static.oschina.net/uploads/img/201704/05150527_7xfl.png "ParNew/Serial Old收集器")

1. ParNew收集器是一个**新生代收集器**。
2. ParNew收集器其实就是Serial收集器的**多线程**版本。
3. 除了使用多条线程进行垃圾收集之外，其余行为包括控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器**完全一样**。
4. 目前，除了Serial收集器外，**只有**ParNew收集器能**与CMS收集器配合**工作。
5. 默认开启的收集线程数**与CPU的数量相同**，在CPU非常多（譬如32个）的环境下，可以使用-XX:ParallelGCThreads参数来**限制垃圾收集的线程数**。
6. 它是许多运行在Server模式下的虚拟机中首选的新生代收集器。

#### 3.3.3 Parallel Scavenge收集器

1. Parallel Scavenge收集器也是一个**新生代收集器**。
2. Parallel Scavenge收集器也使用**复制算法**，并且是并行的**多线程收集器**。
3. 与其他收集器**不同**的是，其他收集器的目标是尽可能缩短垃圾收集时用户线程的**停顿时间**，Parallel Scavenge收集器的目的是达到一个**可控制的吞吐量**。
    > * 停顿时间越短，越是和用户交互程序
    > * 高吞吐量适合主要在**后台运算**，不需要交互的任务。
4. Parallel Scavenge收集器有一个-XX:UseAdaptiveSizePolicy的参数，是一个**自适应调节策略**开关。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的**重要区别**。
    > 打开这个开关之后，就不需要手动指定新生代大小，Eden与Survivor的比理，晋升老年代年龄等参数了。
5. 
6. ~~具体细节，这个文章中没有描述~~

#### 3.3.4 Serial Old收集器

![Serial/Serial Old收集器示意图](https://static.oschina.net/uploads/img/201704/05150746_078R.png "Serial/Serial Old收集器示意图")

1. 是Serial收集器的**老年代**版本。
2. 这个收集器是一个**单线程**的收集器。
3. 使用**标记整理算法**。
4. 主要意义也是**Client模式**下使用。
5. 在Server模式下，有两大用途：
    1. jdk1.5之前的版本中，**搭配Parallel Scavenge**收集器使用。
    2. 作为GMS收集器**后备预案**，在并发收集发生**Concurrent Mode Failure**的时候使用。

#### 3.3.5 Parallel Old收集器

![Parallel Scavenge/Parallel Old收集器示意图](https://static.oschina.net/uploads/img/201704/05150832_q2to.png "Parallel Scavenge/Parallel Old收集器示意图")

1. Parallel Scavenge收集器的**老年代**版本。
2. 使用**多线程**。
3. 使用**标记整理算法**。
4. 在**jdk1.6之后才提供**这种算法。
5. 替代serial Old（效率低，托Parallel Scavenge的高吞吐的后腿）与Parallel Scavenge搭配，真正实现**吞吐量优先**。

#### 3.3.6 CMS收集器（Concurrent Mark Sweep）

![Concurrent Mark Sweep收集器示意图](https://static.oschina.net/uploads/img/201704/05150953_JGmA.png "Concurrent Mark Sweep收集器示意图")

1. CMS收集器是一种以**获取最短回收停顿时间**为目标的收集器。
2. CMS收集器是基于**标记清除**算法实现的
3. CMS收集器的运作过程相对来说**更复杂**一些，整个过程分为**4个步骤**，包括：
    1. **初始标记（CMS initial mark）**
        > 初始标记仅仅只是标记一下GC Roots能**直接关联到**的对象，速度很快。
    2. **并发标记（CMS concurrent mark）**
        > 并发标记阶段就是进行GC RootsTracing的过程。图中可以看到，这个步骤是**可以并发完成**的，**不需要停止**其他工作。
    3. **重新标记（CMS remark）**
        > 重新标记阶段是为了修正**并发标记期间**因用户程序继续运作而导致**标记产生变动**的那一部分对象的标记记录，这阶段的停顿时间一般**比初始标记阶段稍长**，但**远比并发标记短**。
    4. **并发清除（CMS concurrent sweep）**
4. 初始标记和重新标记这两个步骤，仍然需要**Stop The World**。
5. 整个过程中**耗时最长的并发标记和并发清除过程**，收集器线程都可以与用户线程一起工作。所以，总的来说，CMS收集器的内存回收过程是与用户线程**一起并发执行**的。
6. 主要**优点**：
    1. **并发**。
    2. **低停顿**。
7. 主要**缺点**：
    1. 
    2. 
    3. 

#### 3.3.7 G1收集器

1. 
2. 
3. 
4. 
5. 
6. 

#### 3.3.8 垃圾收集器参数总结

1. 
2. 
3. 
4. 
5. 
6. 


### 3.4 内存分配与回收策略

#### 3.4.1 对象优先在Eden分配
#### 3.4.2 大对象直接进入老年代
#### 3.4.3 长期存活的对象将进入老年代
#### 3.4.4 动态对象年领判定
#### 3.4.5 空间分配担保